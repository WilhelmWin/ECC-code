#include "ECC.h"

// Константный параметр эллиптической кривой (121665), используется
// при умножении
static gf _121665 = {0xDB41, 1};

// Базовая точка эллиптической кривой (используется в X25519)
static uch base[32] = {9};

// ========================================================================
// Операция переноса (carry) для элементов эллиптической кривой (GF)
// ========================================================================

// Обеспечивает, чтобы все элементы поля оставались в пределах [0, 2^16-1].
// Если значение превышает 16 бит, лишнее переносится в следующий элемент.
// Это важно для корректности арифметики в конечном поле.
sv car(gf o)
{
    int i;
    lli c;
    for (i = 0; i < 16; i++) {
        o[i] += (1 << 16);  // Добавление 2^16 для избежания отрицательных
                            // значений
        c = o[i] >> 16;     // Вычисляем перенос (если o[i] > 2^16)
        o[(i + 1) * (i < 15)] += c - 1 + 37 * (c - 1) * (i == 15);
        // Перенос в следующий элемент, с коррекцией для последнего
        o[i] -= c << 16;    // Удаляем перенесённую часть, оставляя
                            // только младшие 16 бит
    }
}

// ========================================================================
// Сложение двух элементов поля Галуа (GF)
// ========================================================================

// Производит поэлементное сложение двух массивов a и b, результат
// сохраняется в o.
sv add(gf o, gf a, gf b)
{
    int i;
    for (i = 0; i < 16; i++)
        o[i] = a[i] + b[i];
}

// ========================================================================
// Вычитание двух элементов поля Галуа (GF)
// ========================================================================

// Производит поэлементное вычитание: o = a - b
sv sub(gf o, gf a, gf b)
{
    int i;
    for (i = 0; i < 16; i++)
        o[i] = a[i] - b[i];
}

// ========================================================================
// Умножение двух элементов GF (по модулю)
// ========================================================================

// Выполняется "длинное умножение" двух массивов, результат редуцируется
// с учётом специфических параметров кривой (умножение на 38).
sv mul(gf o, gf a, gf b)
{
    lli i, j, c[31];
    for (i = 0; i < 31; i++)
        c[i] = 0;
    for (i = 0; i < 16; i++)
        for (j = 0; j < 16; j++)
            c[i + j] += a[i] * b[j];  // Умножение с накоплением
    for (i = 16; i < 31; i++)
        c[i - 16] += 38 * c[i];  // Редукция: c[i] «переносится»
                                 // обратно с коэффициентом
    for (i = 0; i < 16; i++)
        o[i] = c[i];  // Промежуточный результат
    car(o);  // Перенос для приведения к нормальной форме
    car(o);  // Повторный перенос для надёжности
}

// ========================================================================
// Возведение в степень -1 (обратный элемент в поле)
// ========================================================================

// Вычисляется обратный по модулю элемент путём последовательного
// возведения в квадрат и умножения, используя свойства поля и оптимизации
// для конкретных битов.
sv inv(gf o, gf i)
{
    gf c;
    int a;
    for (a = 0; a < 16; a++)
        c[a] = i[a];  // Копируем входной элемент
    for (a = 253; a >= 0; a--) {
        sq(c, c);  // Возводим в квадрат
        if (a != 2 && a != 4)  // Пропускаем некоторые итерации для
                               // оптимизации
            mul(c, c, i);  // Умножение на исходное значение
    }
    for (a = 0; a < 16; a++)
        o[a] = c[a];  // Записываем результат
}

// ========================================================================
// Условный выбор между двумя GF-элементами в зависимости от флага
// ========================================================================

// Если b == 1, выбирается p, иначе q. Используется для защиты от
// побитового анализа.
sv sel(gf p, gf q, int b)
{
    lli t, i, b1 = ~(b - 1);  // Преобразование b в битовую маску:
                              // 0 -> 0x0, 1 -> 0xFFFFFFFF
    for (i = 0; i < 16; i++) {
        t = b1 & (p[i] ^ q[i]);  // XOR и маскирование
        p[i] ^= t;  // Обновляем значения в зависимости от флага
        q[i] ^= t;
    }
}

// ========================================================================
// Основной цикл умножения скаляра на точку (главная операция ECC)
// ========================================================================

// Реализация алгоритма scalar multiplication с помощью условного выбора
// и операций в конечном поле.
sv mainloop(lli x[32], uch *z)
{
    gf a, b, c, d, e, f;
    lli p, i;
    for (i = 0; i < 16; i++) {
        b[i] = x[i];       // Копируем x в b (начальное состояние)
        d[i] = a[i] = c[i] = 0;
    }
    a[0] = d[0] = 1;  // Инициализация базовых точек
    for (i = 254; i >= 0; --i) {
        p = (z[i >> 3] >> (i & 7)) & 1;  // Извлечение i-го бита из
                                         // скаляра z
        sel(a, b, p);
        sel(c, d, p);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        sq(d, e);
        sq(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        sq(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        sq(b, e);
        sel(a, b, p);
        sel(c, d, p);
    }
    for (i = 0; i < 16; i++) {
        x[i] = a[i];       // Запись результата обратно в x
        x[i + 16] = c[i];  // Вторая часть результата
    }
}

// ========================================================================
// Распаковка массива байт в элемент поля GF
// ========================================================================

// Преобразует массив из 32 байт в 16 элементов по 16 бит (little-endian).
sv unpack(gf o, const uch *n)
{
    int i;
    for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + ((lli)n[2 * i + 1] << 8);
}

// ========================================================================
// Упаковка элемента GF обратно в массив байт (32 байта)
// ========================================================================

// Производит корректировку значений и преобразует обратно в байтовый
// формат.
sv pack(uch *o, gf n)
{
    int i, j, b;
    gf m;
    car(n);
    car(n);
    car(n);
    for (j = 0; j < 2; j++) {
        m[0] = n[0] - 0xffed;
        for (i = 1; i < 15; i++) {
            m[i] = n[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = n[15] - 0x7fff - ((m[14] >> 16) & 1);
        b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel(n, m, 1 - b);
    }
    for (i = 0; i < 16; i++) {
        o[2 * i] = n[i] & 0xff;
        o[2 * i + 1] = n[i] >> 8;
    }
}

// ========================================================================
// Основная функция: умножение скаляра на точку q = n * p
// ========================================================================

// Принимает скаляр n и точку p, и вычисляет q = n*p на эллиптической
// кривой.
int crypto_scalarmult(uch *q, const uch *n, const uch *p)
{
    uch z[32];
    lli x[32];
    int i;
    for (i = 0; i < 31; ++i)
        z[i] = n[i];
    z[31] = (n[31] & 127) | 64;  // Установка битов согласно X25519
    z[0] &= 248;
    unpack(x, p);
    mainloop(x, z);
    inv(x + 16, x + 16);  // Инвертируем координату Z
    mul(x, x, x + 16);    // Делим X/Z
    pack(q, x);           // Упаковываем результат
    return 0;
}

// ========================================================================
// Умножение скаляра на базовую точку: q = n * G
// ========================================================================

// Упрощённая обёртка, вызывает основную функцию с фиксированной базовой
// точкой.
int crypto_scalarmult_base(uch *q, const uch *n)
{
    return crypto_scalarmult(q, n, base);
}
