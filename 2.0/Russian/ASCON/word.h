#ifndef WORD_H_
#define WORD_H_

#include <stdint.h>
#include "ascon.h"

/* Получить байт из 64-битного слова ASCON */
#define GETBYTE(x, i) ((uint8_t)((uint64_t)(x) >> (8 * (i))))

/* Установить байт в 64-битном слове ASCON */
#define SETBYTE(b, i) ((uint64_t)(b) << (8 * (i)))

/* Установить байт заполнителя в 64-битном слове ASCON */
#define PAD(i) SETBYTE(0x01, i)

/* Определить бит разделения доменов в 64-битном слове ASCON */
#define DSEP() SETBYTE(0x80, 7)

/* Загружать байты в 64-битное слово ASCON */
static inline uint64_t LOADBYTES(const uint8_t* bytes, int n) {
    int i;
    uint64_t x = 0;
    for (i = 0; i < n; ++i) x |= SETBYTE(bytes[i], i);
    return x;
}

/* Сохранять байты из 64-битного слова ASCON */
static inline void STOREBYTES(uint8_t* bytes, uint64_t x, int n) {
    int i;
    for (i = 0; i < n; ++i) bytes[i] = GETBYTE(x, i);
}

/* Очистить байты в 64-битном слове ASCON */
static inline uint64_t CLEARBYTES(uint64_t x, int n) {
    int i;
    for (i = 0; i < n; ++i) x &= ~SETBYTE(0xff, i);
    return x;
}


// =====================================================================
// Раунд
// =====================================================================


// Функция для выполнения циклического сдвига вправо на 'n' позиций для
// 64-битного значения
static inline uint64_t ROR(uint64_t x, int n) {
    return x >> n | x << (-n & 63);  // Сдвиг вправо с циклическим
                                     // переносом
}

// Функция, выполняющая один раунд ASCON перестановки
static inline void ROUND(ascon_state_t* s, uint8_t C) {
    ascon_state_t t;

    /* Добавление постоянной раунда */
    s->x[2] ^= C;

    /* Слой подстановки */
    s->x[0] ^= s->x[4];  // Выполняется XOR с 4-м элементом состояния
    s->x[4] ^= s->x[3];  // Выполняется XOR с 3-м элементом состояния
    s->x[2] ^= s->x[1];  // Выполняется XOR с 1-м элементом состояния

    /* Начало Keccak S-box */
    t.x[0] = s->x[0] ^ (~s->x[1] & s->x[2]);  // XOR с инвертированными
                                              // значениями 1 и 2
    t.x[1] = s->x[1] ^ (~s->x[2] & s->x[3]);  // XOR с инвертированными
                                              // значениями 2 и 3
    t.x[2] = s->x[2] ^ (~s->x[3] & s->x[4]);  // XOR с инвертированными
                                              // значениями 3 и 4
    t.x[3] = s->x[3] ^ (~s->x[4] & s->x[0]);  // XOR с инвертированными
                                              // значениями 4 и 0
    t.x[4] = s->x[4] ^ (~s->x[0] & s->x[1]);  // XOR с инвертированными
                                              // значениями 0 и 1
    /* Конец Keccak S-box */

    t.x[1] ^= t.x[0];  // Выполняется XOR между 1-м и 0-м элементом
    t.x[0] ^= t.x[4];  // Выполняется XOR между 4-м и 0-м элементом
    t.x[3] ^= t.x[2];  // Выполняется XOR между 3-м и 2-м элементом
    t.x[2] = ~t.x[2];  // Инвертируем 2-й элемент

    /* Линейный слой диффузии */
    s->x[0] = t.x[0] ^ ROR(t.x[0], 19) ^ ROR(t.x[0], 28);  // Применяется
                                                           // линейная
                                                           // диффузия для
                                                           // 0-го элемента

    s->x[1] = t.x[1] ^ ROR(t.x[1], 61) ^ ROR(t.x[1], 39);  // Применяется
                                                           // линейная
                                                           // диффузия для
                                                           // 1-го элемента

    s->x[2] = t.x[2] ^ ROR(t.x[2], 1) ^ ROR(t.x[2], 6);    // Применяется
                                                           // линейная
                                                           // диффузия для
                                                           // 2-го элемента

    s->x[3] = t.x[3] ^ ROR(t.x[3], 10) ^ ROR(t.x[3], 17);  // Применяется
                                                           // линейная
                                                           // диффузия для
                                                           // 3-го элемента

    s->x[4] = t.x[4] ^ ROR(t.x[4], 7) ^ ROR(t.x[4], 41);   // Применяется
                                                           // линейная
                                                           // диффузия для
                                                           // 4-го элемента
}

#endif /* WORD_H_ */
