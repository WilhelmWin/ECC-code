#include "drng.h"

// ========================================================================
// RDRAND primitives: функции генерации случайных чисел
// с использованием инструкции RDRAND (для разных размеров).
// ========================================================================

/**
 * Функция: rdrand64_step
 * Назначение: Считает 64-битное случайное значение из аппаратного генератора RDRAND.
 * Параметры:
 *   - rand: указатель на переменную, куда будет записано случайное число
 * Возвращает:
 *   - 1, если значение успешно считано
 *   - 0, если произошла ошибка (например, генератор занят)
 */
int rdrand64_step (uint64_t *rand)
{
    unsigned char ok;

    // Использование ассемблерной вставки: rdrand записывает 64-битное значение,
    // setc устанавливает флаг успеха в переменную `ok`.
    asm volatile ("rdrand %0; setc %1"
        : "=r" (*rand), "=qm" (ok)); // выходные операнды

    return (int) ok;
}

/**
 * Функция: rdrand64_retry
 * Назначение: Повторяет попытки получения случайного числа, если RDRAND временно не готов.
 * Параметры:
 *   - retries: максимальное количество повторов
 *   - rand: указатель на переменную, куда будет записано случайное число
 * Возвращает:
 *   - 1, если удалось получить число
 *   - 0, если все попытки были неудачны
 */
int rdrand64_retry (unsigned int retries, uint64_t *rand)
{
    unsigned int count = 0;

    // Повторять попытки до достижения лимита
    while (count <= retries) {
        if (rdrand64_step(rand)) {
            return 1;  // Успешное получение числа
        }
        ++count;
    }

    return 0;  // Неудача после всех попыток
}

/**
 * Функция: rdrand_get_bytes
 * Назначение: Получает n случайных байтов, используя 64-битные значения от RDRAND.
 * Параметры:
 *   - n: количество байт, которые нужно получить
 *   - dest: указатель на буфер назначения
 * Возвращает:
 *   - количество фактически полученных байт (может быть < n при ошибке)
 */
unsigned int rdrand_get_bytes (unsigned int n, unsigned char *dest)
{
    unsigned char *headstart;      // начало буфера (необязательно выровнено)
    unsigned char *tailstart = NULL; // хвостовая часть (оставшиеся байты)
    uint64_t *blockstart;          // указатель на 64-битно выровненную часть
    unsigned int count, ltail, lhead, lblock;
    uint64_t i, temprand;

    // === Шаг 1: Определяем выравнивание буфера ===
    headstart = dest;

    // Если буфер выровнен по 8 байтам, то можно сразу работать с ним как с uint64_t*
    if (((uint64_t)headstart % 8) == 0) {
        blockstart = (uint64_t *)headstart;
        lblock = n;     // вся длина — центральный блок
        lhead = 0;      // нет начальной невыравненной части
    } else {
        // Вычисляем адрес ближайшего следующего выровненного блока
        blockstart = (uint64_t *)(((uint64_t)headstart & ~7ULL) + 8);

        // lblock — это длина основного блока, исключая head
        lblock = n - (8 - (unsigned int)((uint64_t)headstart % 8));

        // Количество байтов в начальной (невыравненной) части
        lhead = (unsigned int)((uint64_t)blockstart - (uint64_t)headstart);
    }

    // Вычисляем длину хвоста (оставшиеся байты после выровненного блока)
    ltail = n - lblock - lhead;

    // Количество 64-битных значений, которые нужно сгенерировать
    count = lblock / 8;

    // tailstart — адрес начала хвостовой части
    if (ltail) {
        tailstart = (unsigned char *)((uint64_t)blockstart + lblock);
    }

    // === Шаг 2: Обработка начальной (невыравненной) части, если есть ===
    if (lhead) {
        if (!rdrand64_retry(RDRAND_RETRIES, &temprand)) {
            return 0;  // Ошибка на начальной части
        }
        // Копируем только первые lhead байтов из temprand
        memcpy(headstart, &temprand, lhead);
    }

    // === Шаг 3: Основной блок (выровненная часть) ===
    for (i = 0; i < count; ++i, ++blockstart) {
        if (!rdrand64_retry(RDRAND_RETRIES, blockstart)) {
            return i * 8 + lhead;  // Ошибка — возвращаем количество успешных байт
        }
    }

    // === Шаг 4: Хвост (остаток, <8 байтов) ===
    if (ltail) {
        if (!rdrand64_retry(RDRAND_RETRIES, &temprand)) {
            return count * 8 + lhead; // Возвращаем, сколько байтов было получено до ошибки
        }
        memcpy(tailstart, &temprand, ltail);
    }

    // Успешно сгенерировали все 'n' байт
    return n;
}
