#include "session.h"
#include "error.h"
int main(int argc, char *argv[]) {

    // ====================================================================
    // Инициализация структуры для работы клиент-сервер
    // ====================================================================
    ClientServerContext ctx;
    initializeContext(&ctx);  // Инициализация контекста: заполнение
                              // полей по умолчанию

    // ====================================================================
    // Инициализация Winsock (только для Windows)
    // ====================================================================
#ifdef _WIN32
    WSADATA wsaData;
    // Инициализация Winsock для Windows платформы
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        error("WSAStartup провал");
    }
#endif

    // ====================================================================
    // Проверка аргументов входа
    // ====================================================================
    if (argc < 3) {
        error("Проверка...\n"
        "Пользователь не прочитал документацию по использованию клиента.\n"
        "Отсутствует IP-адрес или порт.\n"
        "Формат использования клиента:\n"
        "./client <имя хоста> <порт>\n"
        "Уход в небытие");
    }
    if (argc >= 4){
        error("Проверка...\n"
        "Пользователь не прочитал документацию по использованию клиента.\n"
        "Добавлено дохуя параметров\n"
        "Формат использования клиента:\n"
        "./client <имя хоста> <порт>\n"
        "Уход в небытие");
    }
    // ====================================================================
    // Генерация приватного ключа (Curve25519)
    // ====================================================================
    generate_private_key(ctx.private_key);  // Генерация приватного ключа
                                            // при помощи Curve25519
    printf("Генерация приватного ключа сервера:\n");
    hexdump(ctx.private_key, 32);  // Вывод сгенерированого ключа

    // ====================================================================
    //  Конвертация порта в int
    // ====================================================================
    ctx.portno = atoi(argv[2]);  // Конвертация порта аргумента в формат
                                 // integer

    // ====================================================================
    // Создание TCP сокета
    // ====================================================================
    ctx.sockfd = socket(AF_INET, SOCK_STREAM, 0);  // Создание TCP IPv4
                                                   // сокета
    if (ctx.sockfd < 0) {
        error("ERROR нихуя не открыл сокет");
    }
    printf("Сокет успешно открыт\n");

    // ====================================================================
    // Преобразование имени хоста в IP
    // ====================================================================
    ctx.server = gethostbyname(argv[1]);  // Преобразование имени хоста в
                                          // IP
    if (ctx.server == NULL) {
        error("Крысы в серверной\n"
        "Хоста загрызли\n"
        "Ты же не мог ошибиться в порте или айпи?\n");
    }
    printf("Хост найден\n");

    // ====================================================================
    // Настройка адреса сервера
    // ====================================================================

    ctx.serv_addr.sin_family = AF_INET;  // Выбираем семью IPv4
    memcpy(&ctx.serv_addr.sin_addr.s_addr,
           ctx.server->h_addr,
           ctx.server->h_length);  // копируем размер в длину в структуру
    ctx.serv_addr.sin_port = htons(ctx.portno);  // Преобразовать номер
                                                 // порта в порядок сетевых
                                                 // байтов и сохранить его.

    // ====================================================================
    // Установка соединения
    // ====================================================================
    if (connect(ctx.sockfd,(struct sockaddr *)&ctx.serv_addr,
                sizeof(ctx.serv_addr)) < 0) {
      error("Ошибка подключения.\n"
      "То ли ваш интернет притворяется недоступным\n"
      "то ли сервер ушёл на обеденный сон.\n"
      "Попробуйте позже!\n"
      "Итог таков:");
    }
    printf("Соидинение успешно\n");

    // ====================================================================
    // Обмен ключами (по X25519)
    // ====================================================================

    crypto_scalarmult_base(ctx.public_key, ctx.private_key);  // Генерация
    // публичного ключа клиента с использованием X25519

    // Отправка публичного ключа серверу
#ifdef _WIN32
    int n = send(ctx.sockfd, (char *)ctx.public_key, sizeof(ctx.public_key), 0);
// Преобразование в const char * (Windows)
#else
    int n = write(ctx.sockfd, ctx.public_key, sizeof(ctx.public_key));
// Отправка в UNIX-подобных системах
#endif

    // Проверка успешной отправки публичного ключа
    if (n < 0) {
        error("Ошибка при отправке публичного ключа");
    }

    // Получение публичного ключа сервера
    n = recv(ctx.sockfd, (char *)ctx.server_public_key,
    sizeof(ctx.server_public_key), 0);  // Получение публичного ключа
                                        // от сервера
    if (n < 0) {
        error("Ошибка при получении публичного ключа от сервера");
    }

    // Печать полученного публичного ключа сервера (для отладки)
    printf("Публичный ключ сервера получен:\n");
    hexdump(ctx.server_public_key, 32);  // Вывод публичного ключа
                                         // сервера в шестнадцатеричном
                                         // формате

    // Вычисление общего секрета по протоколу Диффи-Хеллмана (X25519)
    crypto_scalarmult(ctx.shared_secret, ctx.private_key,
                      ctx.server_public_key);
    // Общий секрет вычисляется на основе приватного ключа клиента и
    // публичного ключа сервера

    printf("Вычисленный общий секрет:\n");
    hexdump(ctx.shared_secret, 32);  // Вывод общего секрета в
                                     // шестнадцатеричном формате

    // ====================================================================
    // Начало цикла обмена зашифрованными сообщениями
    // ====================================================================
    while (1) {
        // Получение ввода от пользователя
        printf("Я: ");
        memset(ctx.buffer, 0, sizeof(ctx.buffer));  // Очистка буфера перед
                                                    // вводом сообщения
                                                    // пользователя

        if (fgets((char *)ctx.buffer, sizeof(ctx.buffer), stdin) == NULL) {
            error("Ошибка при чтении ввода");  // Проверка ошибки чтения
                                               // из stdin
        }

        // Удаление символа новой строки, если он есть
        size_t len = strlen((char *)ctx.buffer);
        if (len > 0 && ctx.buffer[len - 1] == '\n') {
            ctx.buffer[len - 1] = '\0';  // Удаление символа новой строки
                                         // в конце строки
        }

        ctx.bufferlen = strlen((char *)ctx.buffer);  // Сохранение длины
                                                     // введённого сообщения

        // Шифрование сообщения
        if (crypto_aead_encrypt(ctx.encrypted_msg, &ctx.encrypted_msglen,
                                ctx.buffer, ctx.bufferlen,
                                ctx.npub,
                                ctx.shared_secret) != 0) {
            error("Ошибка при шифровании сообщения");
        }

        // Отправка зашифрованного сообщения
#ifdef _WIN32
        n = send(ctx.sockfd, (const char *)ctx.encrypted_msg,
                 ctx.encrypted_msglen, 0);  // Отправка зашифрованного
                                            // сообщения (Windows)
#else
        n = write(ctx.sockfd, ctx.encrypted_msg, ctx.encrypted_msglen);
// Отправка зашифрованного сообщения (Linux/Unix)
#endif
        if (n < 0)
            error("Ошибка при отправке сообщения серверу");

        // Если пользователь ввёл "bye", завершить общение
        if (strcasecmp((char *)ctx.buffer, "bye") == 0) {
            printf("Вы завершили разговор.\n");
            break;  // Завершение цикла
        }

        // Очистка буфера перед получением сообщения
        memset(ctx.encrypted_msg, 0, sizeof(ctx.encrypted_msg));

#ifdef _WIN32
        n = recv(ctx.sockfd, (char *)ctx.encrypted_msg,
                 sizeof(ctx.encrypted_msg), 0);  // Получение зашифрованного
                                                 // ответа (Windows)
#else
        n = read(ctx.sockfd, ctx.encrypted_msg,
                 sizeof(ctx.encrypted_msg));     // Получение зашифрованного
                                                 // ответа (Linux/Unix)
#endif
        if (n < 0)
            error("Ошибка при получении сообщения от сервера");

        ctx.encrypted_msglen = n;  // Сохранение фактической длины
                                   // полученного сообщения

        // Расшифровка ответа
        if (crypto_aead_decrypt(ctx.decrypted_msg, &ctx.decrypted_msglen,
                                ctx.nsec,
                                ctx.encrypted_msg, ctx.encrypted_msglen,
                                ctx.npub, ctx.shared_secret) != 0) {
            error("Ошибка при расшифровке сообщения");
        }

        // Добавление терминального нуля к расшифрованной строке
        ctx.decrypted_msg[ctx.decrypted_msglen] = '\0';

        // Вывод расшифрованного сообщения сервера
        printf("Сервер: %s\n", ctx.decrypted_msg);

        // Если сервер отправил "bye", завершить общение
        if (strcasecmp((char *)ctx.decrypted_msg, "bye") == 0) {
            printf("Сервер завершил разговор.\n");
            break;  // Завершение цикла
        }
    }

    // ====================================================================
    // Очистка ресурсов и закрытие сокета
    // ====================================================================
#ifdef _WIN32
    closesocket(ctx.sockfd);  // Закрытие сокета в Windows
    WSACleanup();             // Освобождение ресурсов Winsock
#else
    close(ctx.sockfd);        // Закрытие сокета в Linux/Unix
#endif


exit(0);
}


