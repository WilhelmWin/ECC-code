#ifndef ECC_H
#define ECC_H

// ========================================================================
// Определения типов
// ========================================================================

// 'lli' — это сокращение для 'long long int', которое используется
// для представления длинных целых чисел. Такие числа необходимы при
// операциях с большими значениями, например в криптографии на
// эллиптических кривых.
typedef long long int lli;

// 'gf' — это массив из 16 элементов типа lli. Он представляет элемент
// конечного поля (Galois Field, GF), используемого в вычислениях над
// эллиптическими кривыми. Размер 16 выбран в соответствии с размерностью
// поля Curve25519.
typedef lli gf[16];

// 'uch' — это сокращение от 'unsigned char'. Используется для
// представления байтов (например, при передаче ключей, скаляров и
// точек в виде массива байт).
typedef unsigned char uch;

// ========================================================================
// Определения макросов
// ========================================================================

// 'sv' — макрос, определяющий void-функции (не возвращают значение).
#define sv void

// 'sq(o, i)' — макрос для возведения элемента конечного поля 'i' в
// квадрат с сохранением результата в 'o'. Использует функцию 'mul' для
// перемножения элемента на самого себя.
#define sq(o, i) mul(o, i, i)

// ========================================================================
// Прототипы функций
// ========================================================================

// ========================================================================
// Операция переноса (car)
// ========================================================================
// Функция 'car' обрабатывает переполнение в элементах конечного поля,
// приводя все значения к диапазону [0, 2^16 - 1]. Это необходимо после
// арифметических операций, чтобы результат оставался корректным в рамках
// поля.
sv car(gf o);

// ========================================================================
// Операция сложения (add)
// ========================================================================
// Функция 'add' выполняет поэлементное сложение двух элементов поля
// 'a' и 'b', результат сохраняется в 'o'.
sv add(gf o, gf a, gf b);

// ========================================================================
// Операция вычитания (sub)
// ========================================================================
// Функция 'sub' поэлементно вычитает элемент поля 'b' из 'a',
// результат сохраняется в 'o'.
sv sub(gf o, gf a, gf b);

// ========================================================================
// Операция умножения (mul)
// ========================================================================
// Функция 'mul' выполняет умножение двух элементов конечного поля
// 'a' и 'b', результат сохраняется в 'o'. Используется длинная арифметика
// с последующей корректировкой по модулю параметров кривой
// (например, умножение на 38).
sv mul(gf o, gf a, gf b);

// ========================================================================
// Операция обращения (inv)
// ========================================================================
// Функция 'inv' вычисляет обратный элемент к заданному 'i' в поле,
// результат сохраняется в 'o'. Применяется, например, при делении
// и в процессе получения координат x после скалярного умножения.
sv inv(gf o, gf i);

// ========================================================================
// Условный выбор (sel)
// ========================================================================
// Функция 'sel' выполняет выбор между двумя элементами поля 'p' и 'q'
// на основе булевой переменной 'b'. Если 'b' равно 1 — выбирается 'p',
// иначе — 'q'. Это используется для предотвращения утечек по времени
// в криптографических операциях.
sv sel(gf p, gf q, int b);

// ========================================================================
// Основной цикл скалярного умножения (mainloop)
// ========================================================================
// Функция 'mainloop' реализует скалярное умножение точки эллиптической
// кривой.
// Вход — скаляр 'z' (в виде массива байт) и точка в массиве 'x'.
// Результат: x[0..15] — координата x результирующей точки,
// x[16..31] — знаменатель (для последующего обращения).
sv mainloop(lli x[32], uch *z);

// ========================================================================
// Распаковка байтового массива в элемент поля (unpack)
// ========================================================================
// Функция 'unpack' преобразует байтовый массив 'n' в элемент поля 'o',
// интерпретируя каждые два байта как 16-битное значение.
sv unpack(gf o, const uch *n);

// ========================================================================
// Упаковка элемента поля в байтовый массив (pack)
// ========================================================================
// Функция 'pack' преобразует элемент поля 'n' обратно в байтовый
// массив 'o'.
// Используется перед передачей/сохранением результата скалярного умножения.
sv pack(uch *o, gf n);

// ========================================================================
// Скалярное умножение точки (crypto_scalarmult)
// ========================================================================
// Функция 'crypto_scalarmult' вычисляет произведение скаляра 'n' на
// точку 'p'
// и сохраняет результат в массив 'q'. Это ключевая операция в алгоритмах
// обмена ключами, таких как X25519 (используется в TLS, Signal и др.).
int crypto_scalarmult(uch *q, const uch *n, const uch *p);

// ========================================================================
// Скалярное умножение базовой точки (crypto_scalarmult_base)
// ========================================================================
// Функция 'crypto_scalarmult_base' выполняет умножение скаляра 'n' на
// базовую точку G кривой (обычно это точка с x = 9).
// Результат сохраняется в 'q'. Используется для генерации открытых ключей.
int crypto_scalarmult_base(uch *q, const uch *n);

#endif // ECC_H
