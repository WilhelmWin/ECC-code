# Документация для сервера с криптографической защитой связи ASCON+Curve25519

## Описание программы

Данная программа реализует серверную часть защищённой клиент-серверной связи с использованием алгоритма генерации приватных ключей при помощи Curve25519 обмена ключами Диффи-Хеллмана (Diffie-Hellman) с последующим созданием общего ключа при помощи Curve25519 и шифрования с использованием AEAD (Authenticated Encryption with Associated Data) с помощью ASCON128a. Программа поддерживает работу как на операционных системах Windows, так и на Linux.

### Ключевые особенности:
- Инициализация и управление контекстом для серверной части.
- Генерация приватных ключей при помощи Curve25519
- Обмен ключами с клиентом с использованием алгоритма Диффи-Хеллмана.
- Генерация общего ключа при помощи Curve25519
- Защищённая передача данных через TCP-сокет.
- Шифрование и дешифрование сообщений с использованием алгоритма ASCON128a.
- Поддержка различных платформ (Windows, Linux).

## Библиотеки и зависимости

- **`session.h`** — Содержит все используемые библиотеки проекта, включая Curve25519, ASCON, генерацию приватного ключа при помощи процессора

## Параметры запуска

Программа принимает один обязательный параметр — номер порта для прослушивания:
 
./server port


### Параметры:
- **`port`** — Номер порта для прослушивания входящих соединений.

## Инициализация

Программа выполняет несколько шагов для настройки сокетов и криптографических операций:

1. **Инициализация контекста** — Инициализируется структура `ClientServerContext`, которая управляет параметрами и состоянием серверной части.
2. **Инициализация сокетов (Windows/Linux)** — В зависимости от операционной системы происходит настройка сокетов для общения с клиентом. На Windows используется Winsock, на Linux — стандартные сокеты.
3. **Создание сокета и привязка к адресу** — Сервер создаёт сокет и привязывает его к IP-адресу и порту.
4. **Прослушивание соединений** — Сокет начинает слушать входящие соединения от клиентов.

## Обмен ключами

1. **Генерация приватного ключа** — Сервер генерирует свой приватный ключ для алгоритма Диффи-Хеллмана.
2. **Отправка публичного ключа клиенту** — Сервер отправляет свой публичный ключ клиенту.
3. **Получение публичного ключа от клиента** — Сервер получает публичный ключ клиента.
4. **Вычисление общего секрета** — Сервер использует свой приватный ключ и публичный ключ клиента для вычисления общего секрета, который будет использоваться для шифрования и дешифрования сообщений.

## Шифрование и дешифрование

1. **Шифрование сообщений** — Когда сервер получает сообщение от клиента, оно расшифровывается с использованием общего секрета.
2. **Отправка зашифрованного ответа клиенту** — Сервер шифрует свой ответ и отправляет его клиенту.
3. **Дешифровка сообщений** — Когда сервер получает зашифрованное сообщение, оно дешифруется и выводится на экран.

## Основной цикл общения

Программа выполняет главный цикл общения, который включает в себя:
- Получение зашифрованных сообщений от клиента.
- Дешифровка сообщений с использованием общего секрета.
- Проверку команды завершения общения ("bye").
- Ответ на сообщение клиента с шифрованием ответа и отправкой его клиенту.

## Завершение работы

После завершения общения:
- Закрываются соединение с клиентом и серверный сокет.
- Для Windows очищается ресурсы Winsock.

## Ошибки

Если возникают ошибки на любом этапе (создание сокета, привязка, обмен ключами, шифрование и дешифрование), программа выводит соответствующее сообщение и завершает выполнение с кодом ошибки.

## Пример использования

Пример запуска программы:

```bash
./server 8080
```

## Sever.c

```c
#include "session.h"

int main(int argc, char *argv[]) {

    // ====================================================================
    // Инициализация контекста для клиент-серверной связи
    // ====================================================================
    ClientServerContext ctx; // Объявление структуры
    initializeContext(&ctx); // Инициализация структуры контекста для управления
                              // настройками связи

    // ====================================================================
    // Платформо-специфичная инициализация сокетов для Windows
    // ====================================================================
    #ifdef _WIN32
        WSADATA wsaData 
      // WSADATA wsaData - это структура, которая используется для хранения 
      // информации о версии библиотеки Winsock, а также других данных, 
      // необходимых для работы с сетевыми соединениями в Windows.
        int result = WSAStartup(MAKEWORD(2, 2), &wsaData);  
        
      //  MAKEWORD(2, 2) — это макрос, который создаёт 16-битное число, 
      // представляющее версию библиотеки Winsock. В данном случае,
      // версия Winsock, которая требуется, это 2.2 (то есть, версия 
      // 2 и минорная версия 2).
         
      // &wsaData — указатель на структуру WSADATA, куда будет записана 
      // информация о версии и других параметрах библиотеки Winsock после её инициализации.
        
        
        
        if (result != 0) {
            fprintf(stderr, "Ошибка WSAStartup: %d\n", result);
            exit(1); // Выход в случае ошибки инициализации Winsock
        }
    #endif

    // ====================================================================
    // Проверка аргументов на номер порта
    // ====================================================================
    if (argc < 2) {
        fprintf(stderr, "Использование: %s порт\n", argv[0]); 
        // Печать сообщения о неправильном использовании
        
        #ifdef _WIN32
            WSACleanup();  // Очистка Winsock перед выходом
        #endif
        exit(0); // Выход, если номер порта не был передан
    }

    ctx.portno = atoi(argv[1]);  // Сохранение номера порта из аргументов
                                 // командной строки

    // ====================================================================
    // Генерация случайного приватного ключа для сервера
    // ====================================================================
    generate_private_key(ctx.private_key); // Генерация приватного ключа сервера

    // Печать сгенерированного приватного ключа для отладки
    printf("Сгенерированный приватный ключ для сервера: ");
    print_hex(ctx.private_key, 32);

    // ====================================================================
    // Создание сокета для сервера
    // ====================================================================
    #ifdef _WIN32
        ctx.sockfd = socket(AF_INET, SOCK_STREAM, 0); // Создание TCP сокета
                                                     // на Windows
   // socket — это системный вызов, который создаёт новый сокет и возвращает 
   // его дескриптор (или идентификатор), который затем можно использовать 
   // для взаимодействия с сетевыми интерфейсами. В данном случае это 
   // создаётся сокет для TCP-соединения.

   // AF_INET — это семейство адресов для сокета. В данном случае AF_INET
   // означает, что сокет будет использовать IPv4. 

   // SOCK_STREAM — это тип сокета. SOCK_STREAM указывает, что создаваемый 
   // сокет будет использовать потоковую передачу данных, т.е. это сокет 
   // для соединений с гарантированной доставкой данных (TCP-соединение). 
   
   // 0 — третий аргумент в функции socket — это протокол, который будет 
   // использоваться с данным сокетом. Если передать 0, то операционная
   // система автоматически выберет протокол, подходящий для указанного 
   // типа сокета (в данном случае TCP-протокол для SOCK_STREAM).                                                  
   
        if ((unsigned long long)ctx.sockfd ==
            (unsigned long long)INVALID_SOCKET) {
            error("Ошибка открытия сокета"); // Ошибка открытия сокета
            WSACleanup();  // Очистка Winsock перед выходом
            exit(1); // Выход, если создание сокета не удалось
        }
    #else
        ctx.sockfd = socket(AF_INET, SOCK_STREAM, 0); // Создание TCP сокета
                                                     // на Linux/Unix
        if (ctx.sockfd < 0) {
            error("Ошибка открытия сокета"); // Ошибка открытия сокета
        }
    #endif

    // ====================================================================
    // Подготовка структуры адреса сервера
    // ====================================================================
    memset((char *)&ctx.serv_addr, 0, sizeof(ctx.serv_addr));  // Обнуление
                                                               // структуры
                                                               // адреса
    ctx.serv_addr.sin_family = AF_INET;  // Использование семейства адресов
                                         // Internet
    ctx.serv_addr.sin_addr.s_addr = INADDR_ANY;  // Привязка ко всем доступным
                                                // сетевым интерфейсам
    ctx.serv_addr.sin_port = htons(ctx.portno);  // Установка порта сервера
                                                 // (в сетевом порядке байтов)

    // ====================================================================
    // Привязка сокета к адресу
    // ====================================================================
    int optval = 1; // Установка параметра сокета для разрешения повторного
                    // использования адреса (для корректного завершения)
    #ifdef _WIN32
    
   // ctx.sockfd — это дескриптор сокета, с которым будет ассоциирована опция.
   // Это тот сокет, для которого мы устанавливаем параметры.
   
   // SOL_SOCKET — это уровень, на котором устанавливаются параметры сокета. 
   // В данном случае SOL_SOCKET указывает, что мы устанавливаем опцию на 
   // уровне сокета, а не на уровне конкретного протокола (например, TCP или UDP).

   // SO_REUSEADDR — это опция сокета, которая разрешает повторное 
   // использование адреса и порта. 


        if (setsockopt(ctx.sockfd, SOL_SOCKET, SO_REUSEADDR,
                       (const char *)&optval, sizeof(optval))
        == SOCKET_ERROR) {
            error("Ошибка setsockopt(SO_REUSEADDR)"); // Ошибка установки
                                                      // параметров сокета
            closesocket(ctx.sockfd);
            WSACleanup();  // Очистка Winsock перед выходом
            exit(1); // Выход, если установка параметров сокета не удалась
        }

        if (bind(ctx.sockfd, (struct sockaddr *)&ctx.serv_addr,
                 sizeof(ctx.serv_addr)) == SOCKET_ERROR) {
            error("Ошибка при привязке"); // Ошибка привязки сокета
            closesocket(ctx.sockfd);
            WSACleanup();  // Очистка Winsock перед выходом
            exit(1); // Выход, если привязка не удалась
        }
    #else
        if (setsockopt(ctx.sockfd, SOL_SOCKET, SO_REUSEADDR,
                       &optval, sizeof(optval)) < 0) {
            error("Ошибка setsockopt(SO_REUSEADDR)"); // Ошибка установки
                                                      // параметров сокета
            close(ctx.sockfd);  // Закрытие сокета на Linux/Unix
            exit(1); // Выход, если установка параметров сокета не удалась
        }

        if (bind(ctx.sockfd, (struct sockaddr *)&ctx.serv_addr,
                 sizeof(ctx.serv_addr)) < 0) {
            error("Ошибка при привязке"); // Ошибка привязки сокета
            close(ctx.sockfd);  // Закрытие сокета на Linux/Unix
            exit(1); // Выход, если привязка не удалась
        }
    #endif

    // ====================================================================
    // Ожидание входящих соединений от клиентов
    // ====================================================================
    #ifdef _WIN32
        if (listen(ctx.sockfd, 5) == SOCKET_ERROR) {
            error("Ошибка при прослушивании"); // Ошибка при прослушивании соединений
            WSACleanup();  // Очистка Winsock перед выходом
            exit(1); // Выход, если прослушивание не удалось
        }
    #else
        if (listen(ctx.sockfd, 5) < 0) {
            error("Ошибка при прослушивании"); // Ошибка при прослушивании соединений
        }
    #endif

    // ====================================================================
    // Принятие соединения от клиента
    // ====================================================================
    ctx.clilen = sizeof(ctx.cli_addr);  // Установка размера структуры адреса
                                        // клиента
    #ifdef _WIN32
        ctx.newsockfd = accept(ctx.sockfd,
                           (struct sockaddr *)&ctx.cli_addr, &ctx.clilen);
        if ((unsigned long long)ctx.newsockfd ==
            (unsigned long long)INVALID_SOCKET) {
            error("Ошибка при принятии соединения"); // Ошибка при принятии соединения
            WSACleanup();  // Очистка Winsock перед выходом
            exit(1); // Выход, если принятие соединения не удалось
        }
    #else
        ctx.newsockfd = accept(ctx.sockfd,
                           (struct sockaddr *)&ctx.cli_addr, &ctx.clilen);
        if (ctx.newsockfd < 0) {
            error("Ошибка при принятии соединения"); // Ошибка при принятии соединения
        }
    #endif
    printf("Соединение принято\n");

    // ====================================================================
    // Процесс обмена ключами по Диффи-Хеллману
    // ====================================================================
    unsigned char public_key[32];
    crypto_scalarmult_base(public_key, ctx.private_key);  // Генерация
                                                          // публичного
                                                          // ключа сервера
                                                          // с использованием
                                                          // его приватного ключа

    // Отправка публичного ключа сервера клиенту
    int n = send(ctx.newsockfd, (char *)public_key, sizeof(public_key), 0);
    if (n < 0) {
        error("Ошибка отправки публичного ключа клиенту"); // Ошибка отправки
                                                          // публичного ключа
                                                          // клиенту
    }

    // Получение публичного ключа клиента
    unsigned char client_public_key[32];
    n = recv(ctx.newsockfd, (char *)client_public_key,
             sizeof(client_public_key), 0);
    if (n < 0) {
        error("Ошибка получения публичного ключа от клиента"); // Ошибка получения
                                                                // публичного
                                                                // ключа от клиента
    }

    // Печать полученного публичного ключа клиента
    printf("Полученный публичный ключ клиента: ");
    print_hex(client_public_key, 32);

    // Вычисление общего секретного ключа с использованием Диффи-Хеллмана
    // Вычисление общего секрета
    crypto_scalarmult(ctx.shared_secret, ctx.private_key,
                      client_public_key);

    printf("Общий секретный ключ: ");
    print_hex(ctx.shared_secret, 32);

    // ====================================================================
    // Основной цикл общения с клиентом
    // ====================================================================
    while (1) {
        // Чтение зашифрованного сообщения от клиента
        memset(ctx.encrypted_msg, 0, sizeof(ctx.encrypted_msg)); // Очистка
                                                                 // буфера
                                                                 // зашифрованного
                                                                 // сообщения
        #ifdef _WIN32
            n = recv(ctx.newsockfd, (char *)ctx.encrypted_msg,
                   sizeof(ctx.encrypted_msg), 0); // Получение зашифрованного
                                                 // сообщения на Windows
        #else
            n = read(ctx.newsockfd, ctx.encrypted_msg,
                 sizeof(ctx.encrypted_msg)); // Получение зашифрованного
                                             // сообщения на Linux/Unix
        #endif
        if (n < 0) error("Ошибка чтения от клиента"); // Ошибка чтения
                                                       // сообщения от клиента
        ctx.encrypted_msglen = n; // Сохранение длины полученного
                                  // зашифрованного сообщения

        // Расшифровка полученного сообщения с использованием общего секрета
        if (crypto_aead_decrypt(ctx.decrypted_msg, &ctx.decrypted_msglen,
                                ctx.nsec,
                                ctx.encrypted_msg, ctx.encrypted_msglen,
                                ctx.ad, ctx.adlen,
                                ctx.npub, ctx.shared_secret) != 0) {
            fprintf(stderr, "Ошибка расшифровки\n"); // Ошибка расшифровки
            break;
        }
        // Завершающий нулевой символ для расшифрованного сообщения
        ctx.decrypted_msg[ctx.decrypted_msglen] = '\0';
        // Печать расшифрованного сообщения от клиента
        printf("Клиент: %s\n", ctx.decrypted_msg);


        // Проверка, хочет ли клиент завершить разговор
        if (strcasecmp((char *)ctx.decrypted_msg, "bye") == 0) {
            printf("Клиент завершил разговор.\n");
            break; // Завершение цикла, если клиент завершил разговор
        }

        // Ответ сервера
        printf("Я: ");
        memset(ctx.buffer, 0, sizeof(ctx.buffer));  // Очистка буфера
        if (fgets((char *)ctx.buffer, sizeof(ctx.buffer), stdin) == NULL)
        {
            error("Ошибка ввода"); // Ошибка чтения ввода от сервера
        }

        ctx.bufferlen = strlen((char *)ctx.buffer); // Сохранение длины ввода
                                                   // сервера

        // Удаление завершающего символа новой строки из ввода, если он есть
        if (ctx.bufferlen > 0 && ctx.buffer[ctx.bufferlen - 1] == '\n')
        {
            ctx.buffer[ctx.bufferlen - 1] = '\0'; // Удаление символа новой строки
                                                   // из конца строки
        }

        ctx.bufferlen = strlen((char *)ctx.buffer); // Перерасчет длины
                                                    // буфера

        // Шифрование ответа сервера
        if (crypto_aead_encrypt(ctx.encrypted_msg, &ctx.encrypted_msglen,
                                (unsigned char *)ctx.buffer,
                                ctx.bufferlen,
                                ctx.ad, ctx.adlen, ctx.nsec, ctx.npub,
                                ctx.shared_secret) != 0) {
            fprintf(stderr, "Ошибка шифрования\n"); // Ошибка шифрования
            break;
        }

        #ifdef _WIN32
        // Отправка зашифрованного ответа на Windows
        n = send(ctx.newsockfd, (char *)ctx.encrypted_msg,
                 ctx.encrypted_msglen, 0);
        #else
        // Отправка зашифрованного ответа на Linux/Unix
            n = write(ctx.newsockfd, ctx.encrypted_msg,
                  ctx.encrypted_msglen);
        #endif
        if (n < 0) error("Ошибка записи клиенту"); // Ошибка записи клиенту

        // Проверка, хочет ли сервер завершить связь
        if (strcasecmp((char *)ctx.buffer, "bye") == 0) {
            printf("Вы завершили разговор.\n");
            break; // Завершение цикла, если сервер завершил разговор
        }
    }

    // ====================================================================
    // Закрытие сокетов и очистка ресурсов
    // ====================================================================
    #ifdef _WIN32
        closesocket(ctx.newsockfd);  // Закрытие сокета клиента
        closesocket(ctx.sockfd);  // Закрытие сокета сервера
        WSACleanup();  // Очистка Winsock перед выходом
    #else
        close(ctx.newsockfd);  // Закрытие сокета клиента
        close(ctx.sockfd);  // Закрытие сокета сервера
    #endif

    return 0; // Завершение программы
}

