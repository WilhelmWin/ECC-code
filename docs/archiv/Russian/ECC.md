# Документация для файла ECC

## Описание

Этот файл содержит определения типов, макросы и прототипы функций для операций с эллиптическими кривыми (ECC), включая базовую арифметику (сложение, вычитание, умножение), скалярное умножение и вычисление обратных элементов в поле Галуа (GF). Эти операции являются основными для выполнения криптографических вычислений с использованием эллиптических кривых, таких как обмен ключами Диффи-Хеллмана и генерация публичных ключей.

### Ключевые особенности:
- Операции арифметики в поле Галуа (сложение, вычитание, умножение, инверсия).
- Скалярное умножение и связанные с ним алгоритмы.
- Упаковка и распаковка точек эллиптической кривой.
- Условный выбор значений.
- Скалярное умножение с использованием базовой точки для генерации публичного ключа.

### Используемые библиотеки:
- Заголовочный файл предназначен для работы с криптографической реализацией, использующей типы данных `long long int` (lli) для больших чисел и массивы `unsigned char` для представления байтов.
- `ECC.h` - коммуникация с внешним миром
- `session.h` - для двух переменных в соответствующем разделе для работы кривой 

### Зависимости от платформы:
Этот код является платформонезависимым и может быть использован как в Linux, так и в Windows с минимальными изменениями.

## Аргументы и функциональность:
Функции в этом заголовочном файле выполняют различные операции для криптографии с использованием эллиптических кривых, включая скалярное умножение и арифметику в поле Галуа. Некоторые важные функции включают:
- `add`, `sub`, `mul`, `inv` для арифметики в поле Галуа.
- `crypto_scalarmult` для скалярного умножения с использованием точки `p` и скаляра `n`.
- `crypto_scalarmult_base` для скалярного умножения с использованием базовой точки кривой.
- `pack` и `unpack` для преобразования между байтовыми массивами и элементами поля Галуа.

## Переменные?

Переменные для использования Curve25519 находятся в библиотеке `session.h`, а именно константа _121665 и базовая точка G
## Пример использования:
### 1. Для выполнения скалярного умножения:
```c
    unsigned char q[32];
    const unsigned char n[32] = {...}; // скалярное значение
    const unsigned char p[32] = {...}; // точка эллиптической кривой
    crypto_scalarmult(q, n, p); // q = n * p
```
### 2. Для распаковки байтового массива в элемент поля Галуа:
```c
    gf o;
    unpack(o, n); // n — это байтовый массив
```
### 3. Для упаковки элемента поля Галуа в байтовый массив:
```c
    uch o[32];
    pack(o, n); // n — это элемент поля Галуа
```
# Описание функций:

### `car(gf o)`
- Эта функция выполняет операцию переноса для элементов поля Галуа, чтобы убедиться, что все элементы находятся в диапазоне `[0, 2^16-1]`. Она добавляет перенос, если элемент превышает 16 бит, и корректирует следующий элемент, если это необходимо.

1. Перебирает все 16 элементов массива `o`.
2. Добавляет 2^16 к каждому элементу, если это необходимо.
3. После вычисления переноса, корректирует элементы для сохранения их в пределах диапазона.

### `add(gf o, gf a, gf b)`
- Эта функция выполняет сложение двух элементов поля Галуа поэлементно и сохраняет результат в `o`.

1. Применяет поэлементное сложение между массивами `a` и `b`.
2. Результат сохраняется в массив `o`.

### `sub(gf o, gf a, gf b)`
- Эта функция выполняет вычитание элементов поля Галуа поэлементно и сохраняет результат в o.

1. Применяет поэлементное вычитание между массивами `a` и `b`.
2. Результат сохраняется в массив `o`.

### `mul(gf o, gf a, gf b)`
- Эта функция выполняет умножение двух элементов поля Галуа с использованием длинного умножения и учитывает параметры кривой.

1. Используется умножение поэлементно между массивами `a` и `b`.

2. После умножения, результат сохраняется в массив `c`, затем корректируется для параметров кривой.

3. Выполняется операция переноса для корректировки полученных элементов.

### `inv(gf o, gf i)`
- Эта функция вычисляет обратный элемент для поля Галуа с использованием метода возведения в квадрат и умножения.

1. Вначале копируется входной элемент `i` в временный массив `c`.
2. Затем выполняется `253` итерации, в которых каждый раз элемент возводится в квадрат, а при необходимости умножается на элемент i для вычисления его обратного значения.
3. В результате массив `c` содержит обратный элемент для `i`.

### `sel(gf p, gf q, int b)`
- Эта функция выполняет условный выбор между двумя элементами поля Галуа на основе значения `b` (0 или 1). Если `b` равно `1`, выбирается `p`, если `0 — q`.

1. Использует побитовые операции XOR для выбора между массивами p и q.

### `mainloop(lli x[32], uch *z)`
- Этот цикл выполняет скалярное умножение поэлементно, обрабатывая каждый бит скаляра и выполняя операции на эллиптической кривой.

1. Инициализирует несколько массивов для работы с элементами поля.
2. Процесс скалярного умножения состоит в том, чтобы для каждого бита скаляра применить операции условного выбора, сложения, вычитания и умножения, что является частью алгоритма эллиптической кривой.
### `unpack(gf o, const uch *n)`
- Эта функция преобразует байтовый массив n в элемент поля Галуа `o`, расширяя каждый байт в 16-битные элементы.

1. Для каждого байта из массива n создается 16-битный элемент и сохраняется в массив `o`.

### `pack(uch *o, gf n)`
- Эта функция преобразует элемент поля Галуа `n` обратно в байтовый массив `o`.

1. Выполняется несколько операций корректировки для параметров кривой.

2. Каждый элемент поля Галуа преобразуется в два байта и сохраняется в массив `o`.

### `crypto_scalarmult(uch *q, const uch *n, const uch *p)`
- Эта функция выполняет скалярное умножение точки p на скаляр n, используя алгоритм эллиптической кривой.

1. Байтовый массив n копируется в массив `z`.
2. Точка p распаковывается в поле Галуа, затем выполняется основной цикл скалярного умножения.
3. После выполнения умножения, результат инвертируется, затем умножается на сам себя, и результат упаковывается в `q`.

### В нашем случае клиента и сервера

- q: Общий ключ
- n: Приватный ключ хоста
- p: Публичный ключ коннектора 


### `crypto_scalarmult_base(uch *q, const uch *n)`
- Выполняет скалярное умножение с использованием базовой точки эллиптической кривой. Получается `q = n * G`, где `G` — это базовая точка, а `n` — скаляр. Результат сохраняется в `q`.

#### В нашем случае клиента и сервера

- q: Публичный ключ хоста
- n: Приватным ключом хоста

# ECC.c

## 1. `car` (Carry operation for elliptic curve elements)

```c
sv car(gf o)
{
    int i;
    lli c;
    for (i = 0; i < 16; i++) {
        o[i] += (1 << 16);  // Обеспечить, чтобы все элементы находились в правильном диапазоне
        c = o[i] >> 16;  // Перенос, если значение элемента превышает 16 бит
        o[(i + 1) * (i < 15)] += c - 1 + 37 * (c - 1) * (i == 15);
        // При необходимости скорректировать следующий элемент
        o[i] -= c << 16;  // Удержать текущий элемент в пределах диапазона
    }
}
```
- `for (i = 0; i < 16; i++)`: Этот цикл проходит по всем 16 элементам массива o, представляющему элемент поля Галуа GF.

- `o[i] += (1 << 16);`: Для каждого элемента добавляется 65536 (это эквивалентно 2^16), чтобы обеспечить правильный диапазон значений.

- `c = o[i] >> 16;`: Получаем перенос (carry) из старших разрядов, если значение элемента больше 16 бит.

- `o[(i + 1) * (i < 15)] += c - 1 + 37 * (c - 1) * (i == 15);`: Если это не последний элемент (i < 15), то перенос добавляется к следующему элементу.

- `o[i] -= c << 16;`: Восстанавливаем текущий элемент, исключая перенос, чтобы он оставался в пределах диапазона 0..65535.

## 2. `add` (Addition of two GF elements)

```c
sv add(gf o, gf a, gf b)
{
    int i;
    for (i = 0; i < 16; i++)
        o[i] = a[i] + b[i];  // Поэлементное сложение
}
```

- `for (i = 0; i < 16; i++)`: Простой цикл для поэлементного сложения двух элементов поля Галуа `a` и `b` и сохранения результата в массив `o`. Здесь для каждого индекса `i` выполняется сложение соответствующих элементов.

## 3. `sub` (Subtraction of two GF elements)
```c
sv sub(gf o, gf a, gf b)
{
    int i;
    for (i = 0; i < 16; i++)
        o[i] = a[i] - b[i];  // Поэлементное вычитание
}
```

- `for (i = 0; i < 16; i++)`: Подобно сложению, цикл выполняет поэлементное вычитание элементов поля Галуа `b` из элементов поля Галуа `a` и сохраняет результат в массив `o`.

## 4. `mul` (Multiplication of two GF elements)
```c
sv mul(gf o, gf a, gf b)
{
    lli i, j, c[31];
    for (i = 0; i < 31; i++)
        c[i] = 0;  // Инициализация массива переноса
    for (i = 0; i < 16; i++)
        for (j = 0; j < 16; j++)
            c[i + j] += a[i] * b[j];  // Умножение и накопление результатов
    for (i = 16; i < 31; i++)
        c[i - 16] += 38 * c[i];  // Коррекция с учётом специфики кривой
    for (i = 0; i < 16; i++)
        o[i] = c[i];  // Сохранение результата в массив
    car(o);  // Операция переноса для корректировки результата
    car(o);  // Дополнительная операция переноса для безопасности
}

```
- `c[31]`: Создается массив для хранения промежуточных результатов умножения двух элементов поля Галуа.

- `for (i = 0; i < 16; i++)` и вложенный цикл `for (j = 0; j < 16; j++)`: Эти два цикла выполняют поэлементное умножение каждого элемента массива a на каждый элемент массива `b`. Результаты умножения добавляются в массив c по индексам `i` + `j`.

- `c[i - 16] += 38 * c[i];`: После основного умножения добавляется коррекция для параметров кривой (с учетом её характеристик).

- `car(o);`: Применяется операция переноса для корректировки результата.

## 5. `inv` (Inversion of a GF element)
```c
sv inv(gf o, gf i)
{
    gf c;
    int a;
    for (a = 0; a < 16; a++)
        c[a] = i[a];  // Копирование входного значения во временный массив
    for (a = 253; a >= 0; a--) {
        sq(c, c);  // Возведение элемента в квадрат
        if (a != 2 && a != 4)  // Пропуск определённых итераций для повышения эффективности
            mul(c, c, i);  // Умножение на обратный элемент, если это необходимо
    }
    for (a = 0; a < 16; a++)
        o[a] = c[a];  // Сохранение окончательного результата обратного элемента
}

```
- `for (a = 253; a >= 0; a--)`: Этот цикл выполняет процесс вычисления обратного элемента в поле Галуа с использованием метода возведения в квадрат и умножения (алгоритм Эдвардса). Каждый шаг в цикле — это либо возведение в квадрат, либо умножение на элемент `i`.

- `if (a != 2 && a != 4)`: На определенных итерациях пропускается умножение, чтобы повысить эффективность.

## 6. `sel` (Conditional select between two GF elements)
```c
sv sel(gf p, gf q, int b)
{
    lli t, i, b1 = ~(b - 1); // b1 используется для побитовых операций
    for (i = 0; i < 16; i++) {
        t = b1 & (p[i] ^ q[i]);  // Выполнение побитовой операции XOR и применение маски
        p[i] ^= t;  // Выбор p или q в зависимости от флага b
        q[i] ^= t;
    }
}

```
- `for (i = 0; i < 16; i++)`: Проходит по всем элементам и выполняет побитовую операцию XOR между элементами `p` и `q` в зависимости от флага `b`. Этот флаг определяет, какой из двух массивов (`p`или `q`) будет выбран.

## 7. `mainloop` (Main loop for scalar multiplication)
```c
sv mainloop(lli x[32], uch *z)
{
    gf a, b, c, d, e, f;
    lli p, i;
    for (i = 0; i < 16; i++) {
        b[i] = x[i];  // Инициализация b с входным скаляром
        d[i] = a[i] = c[i] = 0;  // Установка остальных элементов в 0
    }
    a[0] = d[0] = 1;  // Установка начальных значений для a и d
    for (i = 254; i >= 0; --i) {
        p = (z[i >> 3] >> (i & 7)) & 1;  // Извлечение i-го бита из скаляра
        sel(a, b, p);  // Условный выбор между a и b на основе бита
        sel(c, d, p);  // То же для c и d
        add(e, a, c);  // Выполнение операций эллиптической кривой
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        sq(d, e);  // Возведение элементов в квадрат
        sq(f, a);
        mul(a, c, a);  // Умножение и добавление результатов
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        sq(b, a);
        sub(c, d, f);
        mul(a, c, _121665);  // Умножение на константу (_121665)
        add(a, a, d);  // Добавление результатов
        mul(c, c, a);  // Дополнительные операции эллиптической кривой
        mul(a, d, f);
        mul(d, b, x);  // Умножение на точку скаляра
        sq(b, e);
        sel(a, b, p);  // Финальный условный выбор на основе бита
        sel(c, d, p);
    }
    for (i = 0; i < 16; i++) {
        x[i] = a[i];  // Сохранение результата в x
        x[i + 16] = c[i];  // Сохранение второй части результата
    }
}

```
- `for (i = 254; i >= 0; --i)`: Это главный цикл, который обрабатывает каждый бит скаляра и выполняет операции эллиптической кривой на основе этого бита. Каждая итерация выполняет множество операций, таких как сложение, вычитание, умножение и возведение в квадрат, что является типичной операцией в алгоритме быстрого умножения на скаляр на эллиптической кривой.

## 8. `crypto_scalarmult` и `crypto_scalarmult_base`

- Эти функции выполняют операцию умножения точки на скаляр. crypto_scalarmult принимает точку p и скаляр n, в то время как crypto_scalarmult_base использует базовую точку (например, в криптографии, это может быть точка на кривой, заранее выбранная).