# Документация для клиента с криптографической защитой связи ASCON+Curve25519

## Описание программы

Эта программа реализует клиентскую часть защищённой клиент-серверной связи с использованием алгоритма генерации приватных ключей при помощи Curve25519 обмена ключами Диффи-Хеллмана (Diffie-Hellman) с последующим созданием общего ключа при помощи Curve25519 и шифрования с использованием AEAD (Authenticated Encryption with Associated Data) с помощью ASCON128a. Программа поддерживает работу как на операционных системах Windows, так и на Linux.

### Ключевые особенности:
- Инициализация и управление контекстом для клиентской части.
- Генерация приватных ключей при помощи Curve25519.
- Обмен ключами с сервером с использованием алгоритма Диффи-Хеллмана.
- Генерация общего ключа при помощи Curve25519.
- Защищённая передача данных через TCP-сокет.
- Шифрование и дешифрование сообщений с использованием алгоритма ASCON128a.
- Поддержка различных платформ (Windows, Linux).

## Библиотеки и зависимости

- **`session.h`** — Содержит все используемые библиотеки проекта, включая Curve25519, ASCON, генерацию приватного ключа при помощи процессора.

## Параметры запуска

Программа принимает два обязательных параметра — имя хоста (IP адрес сервера) и номер порта для подключения:

```bash
./client hostname port
```

## Параметры:

- **hostname** — IP адрес сервера, к которому клиент подключается.
- **port** — Номер порта для подключения к серверу.

## Инициализация

Программа выполняет несколько шагов для настройки сокетов и криптографических операций:

1. **Инициализация контекста** — Инициализируется структура `ClientServerContext`, которая управляет параметрами и состоянием клиентской части.

2. **Инициализация сокетов (Windows/Linux)** — В зависимости от операционной системы происходит настройка сокетов для общения с сервером. На Windows используется Winsock, на Linux — стандартные сокеты.

3. **Проверка входных аргументов** — Программа проверяет правильность переданных аргументов (имя хоста и порт).

4. **Генерация приватного ключа** — Клиент генерирует свой приватный ключ для алгоритма Диффи-Хеллмана.

5. **Создание TCP-сокета и подключение к серверу** — Создаётся сокет, и клиент пытается подключиться к серверу.

## Обмен ключами

1. **Генерация публичного ключа** — Клиент генерирует свой публичный ключ с использованием алгоритма X25519.

2. **Отправка публичного ключа серверу** — Клиент отправляет свой публичный ключ на сервер.

3. **Получение публичного ключа от сервера** — Клиент получает публичный ключ от сервера.

4. **Вычисление общего секрета** — Клиент использует свой приватный ключ и публичный ключ сервера для вычисления общего секрета, который будет использоваться для шифрования и дешифрования сообщений.

## Шифрование и дешифрование

1. **Шифрование сообщений** — Когда клиент вводит сообщение, оно шифруется с использованием общего секрета.

2. **Отправка зашифрованного сообщения на сервер** — Клиент отправляет зашифрованное сообщение на сервер.

3. **Получение зашифрованного ответа от сервера** — Клиент получает зашифрованный ответ от сервера.

4. **Дешифровка ответа** — Клиент дешифрует ответ от сервера с использованием общего секрета и выводит его на экран.

## Основной цикл общения

Программа выполняет главный цикл общения, который включает в себя:

1. Ввод сообщений пользователем и их шифрование.

2. Отправка зашифрованных сообщений серверу.

3. Получение и дешифровка ответа от сервера.

4. Проверку команды завершения общения ("bye").

5. Завершение общения при получении команды "bye" от клиента или сервера.

## Завершение работы

После завершения общения:

1. Закрывается соединение с сервером и клиентский сокет.

2. Для Windows очищаются ресурсы Winsock.

## Ошибки

Если возникают ошибки на любом этапе (создание сокета, подключение, обмен ключами, шифрование и дешифрование), программа выводит соответствующее сообщение и завершает выполнение с кодом ошибки.

## Пример использования

Пример запуска программы:

```bash
./client 127.0.0.1 8080
```

## Client.c

```c

#include "session.h"

int main(int argc, char *argv[]) {

    // ====================================================================
    // Инициализация контекста для клиент-серверного общения
    // ====================================================================
    ClientServerContext ctx;
    initializeContext(&ctx);  // Инициализация структуры контекста для управления
                              // настройками связи

    // ====================================================================
    // Инициализация для Windows (Winsock)
    // ====================================================================
#ifdef _WIN32
    WSADATA wsaData;
    // Инициализация Winsock для Windows
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        printf("Не удалось инициализировать Winsock\n");
        return 1;  // Завершаем программу, если инициализация Winsock не удалась
    }
#endif

    // ====================================================================
    // Проверка входных аргументов (hostname и порт)
    // ====================================================================
    if (argc < 3) {
        fprintf(stderr, "Использование %s hostname port\n", argv[0]);  // Печать
                                                                        // инструкции
        exit(0);  // Завершаем программу, если аргументы некорректны
    }

    // ====================================================================
    // Генерация приватного ключа с использованием Curve25519
    // ====================================================================
    generate_private_key(ctx.private_key);  // Генерация приватного ключа
                                            // с использованием Curve25519
    printf("Сгенерирован приватный ключ для клиента: ");
    print_hex(ctx.private_key, 32);  // Печать сгенерированного приватного ключа в
                                     // шестнадцатеричном формате

    // ====================================================================
    // Преобразование номера порта из строки в целое число
    // ====================================================================
    ctx.portno = atoi(argv[2]);  // Преобразование аргумента порта (строка)
                                 // в целое число

    // ====================================================================
    // Создание TCP-сокета
    // ====================================================================
    ctx.sockfd = socket(AF_INET, SOCK_STREAM, 0);  // Создание IPv4 TCP
                                                   // сокета
    if (ctx.sockfd < 0) {
        error("Ошибка при открытии сокета");  // Если создание сокета не удалось, выводим
                                              // сообщение об ошибке
    }
    printf("Сокет успешно открыт\n");

    // ====================================================================
    // Разрешение имени хоста в IP-адрес
    // ====================================================================
    ctx.server = gethostbyname(argv[1]);  // Преобразование имени хоста в
                                          // IP-адрес
    if (ctx.server == NULL) {
        fprintf(stderr, "Ошибка, такой хост не существует\n");  // Выводим сообщение
                                                                 // об ошибке, если хост
                                                                 // не найден
        exit(0);  // Завершаем программу, если не удалось разрешить хост
    }
    printf("Хост найден\n");

    // ====================================================================
    // Подготовка структуры для адреса сервера
    // ====================================================================
    memset((char *)&ctx.serv_addr, 0, sizeof(ctx.serv_addr));  // Обнуляем
                                                              // структуру
                                                              // адреса сервера

    ctx.serv_addr.sin_family = AF_INET;  // Устанавливаем семейство адресов на IPv4
    memcpy((char *)&ctx.serv_addr.sin_addr.s_addr,
           (char *)ctx.server->h_addr,
           ctx.server->h_length);  // Копируем IP-адрес сервера в структуру
    ctx.serv_addr.sin_port = htons(ctx.portno);  // Преобразуем номер порта в
                                                 // сетевой порядок байтов
                                                 // и сохраняем его

    // ====================================================================
    // Установление соединения с сервером
    // ====================================================================
    if (connect(ctx.sockfd,(struct sockaddr *)&ctx.serv_addr,
                sizeof(ctx.serv_addr)) < 0) {

        error("Ошибка при подключении");  // Пытаемся подключиться к серверу; выводим
                                         // ошибку, если не удалось подключиться
    }
    printf("Подключение успешно\n");

    // ====================================================================
    // Выполнение обмена ключами Диффи-Хеллмана (X25519)
    // ====================================================================
    unsigned char public_key[32];  // Буфер для публичного ключа клиента
    crypto_scalarmult_base(public_key, ctx.private_key);  // Генерация
                                                          // публичного
                                                          // ключа клиента
                                                          // с использованием X25519

    // Отправка публичного ключа на сервер
    #ifdef _WIN32
    int n = send(ctx.sockfd, (const char *)public_key, sizeof(public_key),
               0);  // Преобразование в const char *
#else
   int n = write(ctx.sockfd, public_key, sizeof(public_key));
#endif
    // Отправка сгенерированного публичного ключа серверу
    if (n < 0) {
        error("Ошибка при отправке публичного ключа");  // Проверка успешности
                                                        // отправки публичного ключа
    }

    // Получение публичного ключа от сервера
    unsigned char server_public_key[32];
    n = recv(ctx.sockfd, (char *)server_public_key,
             sizeof(server_public_key), 0);  // Получение публичного ключа сервера
    if (n < 0) {
        error("Ошибка при получении публичного ключа от сервера");
        // Проверка успешности получения публичного ключа
    }

    // Печать полученного публичного ключа сервера (для отладки)
    printf("Получен публичный ключ сервера: ");
    print_hex(server_public_key, 32);  // Печать полученного публичного ключа сервера

    // Вычисление общего секрета с использованием обмена ключами Диффи-Хеллмана
    crypto_scalarmult(ctx.shared_secret, ctx.private_key,
                      server_public_key);  // Вычисление общего секрета на основе
                                            // приватного ключа клиента и публичного
                                            // ключа сервера

    printf("Общий секрет: ");
    print_hex(ctx.shared_secret, 32);  // Печать общего секрета

    // ====================================================================
    // Запуск цикла обмена зашифрованными сообщениями
    // ====================================================================
    while (1) {
        // Получение ввода от пользователя
        printf("Я: ");
        memset(ctx.buffer, 0, sizeof(ctx.buffer));  // Очищаем буфер
                                                    // для хранения
                                                    // сообщения пользователя
        if (fgets((char *)ctx.buffer, sizeof(ctx.buffer), stdin) == NULL)
        {
            error("Ошибка при чтении ввода");  // Чтение ввода с клавиатуры,
                                               // проверка на ошибку
        }

        // Удаление символа новой строки, если он присутствует
        size_t len = strlen((char *)ctx.buffer);
        if (len > 0 && ctx.buffer[len - 1] == '\n') {
            ctx.buffer[len - 1] = '\0';  // Удаление символа новой строки из
                                         // строки ввода
        }
        ctx.bufferlen = strlen((char *)ctx.buffer);  // Сохраняем длину
                                                     // сообщения

        // Шифрование сообщения
        if (crypto_aead_encrypt(ctx.encrypted_msg, &ctx.encrypted_msglen,
                                ctx.buffer, ctx.bufferlen,
                                ctx.ad, ctx.adlen, ctx.nsec, ctx.npub,
                                ctx.shared_secret) != 0) {
            fprintf(stderr, "Ошибка шифрования\n");  // Если шифрование не
                                                    // удалось, выводим
                                                    // сообщение об ошибке
            return 1;
        }

        // Отправка зашифрованного сообщения
#ifdef _WIN32
n = send(ctx.sockfd, (const char *)ctx.encrypted_msg,
                 ctx.encrypted_msglen, 0);  // Отправка зашифрованного сообщения
                                            // на Windows
#else
        n = write(ctx.sockfd, ctx.encrypted_msg, ctx.encrypted_msglen);
// Отправка зашифрованного сообщения на Linux/Unix
#endif
        if (n < 0) error("Ошибка при записи на сервер");  // Проверка на ошибки
                                                          // при отправке

        // Если клиент ввёл "bye", завершаем общение
        if (strcasecmp((char *)ctx.buffer, "bye") == 0) {
            printf("Вы завершили разговор.\n");
            break;  // Выход из цикла, если клиент ввёл "bye"
        }

        // Получение зашифрованного ответа от сервера
        memset(ctx.encrypted_msg, 0, sizeof(ctx.encrypted_msg));
// Очищаем буфер зашифрованного сообщения
#ifdef _WIN32
n = recv(ctx.sockfd, (char *)ctx.encrypted_msg,
             sizeof(ctx.encrypted_msg), 0);  // Получение зашифрованного
// ответа от сервера на Windows
#else
        n = read(ctx.sockfd, ctx.encrypted_msg,
             sizeof(ctx.encrypted_msg));  // Получение зашифрованного
   // ответа от сервера на Linux/Unix
#endif
        if (n < 0) error("Ошибка при чтении с сервера");
// Проверка на ошибки при получении
        ctx.encrypted_msglen = n;  // Сохраняем фактическую длину полученных данных

        // Дешифровка ответа
        if (crypto_aead_decrypt(ctx.decrypted_msg, &ctx.decrypted_msglen,
                                ctx.nsec,
                                ctx.encrypted_msg, ctx.encrypted_msglen,
                                ctx.ad, ctx.adlen,
                                ctx.npub, ctx.shared_secret) != 0) {
            fprintf(stderr, "Ошибка дешифрования\n");  // Если дешифрование
                                                    // не удалось, выводим
                                                    // сообщение об ошибке
            return 1;
        }

        ctx.decrypted_msg[ctx.decrypted_msglen] = '\0';  // Завершаем строку
                                                         // дешифрованного
                                                       // сообщения
        printf("Сервер: %s\n", ctx.decrypted_msg);  // Печать дешифрованного
                                                    // ответа от сервера

        // Если сервер ввёл "bye", завершаем общение
        if (strcasecmp((char *)ctx.decrypted_msg, "bye") == 0) {
            printf("Сервер завершил разговор.\n");
            break;  // Выход из цикла, если сервер ввёл "bye"
        }
    }

    // ====================================================================
    // Очистка и закрытие сокета
    // ====================================================================
#ifdef _WIN32
    closesocket(ctx.sockfd);  // Закрытие сокета на Windows
    WSACleanup();             // Очистка ресурсов Winsock
#else
    close(ctx.sockfd);        // Закрытие сокета на Linux/Unix
#endif

    return 0;  // Успешный выход из программы
}
