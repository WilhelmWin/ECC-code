# Документация для файла Session

## Обзор

Данный раздел предназначен для объяснения кода **`session.h`** и **`session.c`**

### Основные особенности данного кода:
- Содержит системные библиотеки С
- Содержит специальные библиотеки Windows и Linux для сокетов
- Объявление размеров при помощи define
- Структуру со всеми переменными используемые клиентом и сервером
- Функцию для инициализации структуры
- Функцию для вывода ключей в шестнадцатеричном формате.
- Функцию вывода ошибок
- Функцию генерации ключей с вызовом функции с файла drng
- Функцию вывода дамп данных

## Файл: `session.h`

### Используемые библиотеки:
- **`netinet/in.h`**: Для структур и функций сокетов на Unix-подобных системах.
- **`sys/types.h`, `sys/socket.h`, `unistd.h`**: Для работы с сокетами и системных вызовов на Unix-подобных системах.
- **`stdint.h`**: Для типов фиксированной ширины, таких как `uint8_t`.
- **`ECC.h`**: Библиотека для Curve25519.
- **`ASCON/crypto_aead.h`**: Библиотека для работы с ASCON
- **`string.h`**: Для строковых функций (например, `memset()`, `memcpy()`).
- **`stdio.h`**: Для стандартных функций ввода/вывода (например, `printf()`).
- **`stdlib.h`**: Для стандартных функций библиотеки (например, `malloc()`).
- **`winsock2.h`**: Для работы с сокетами в Windows.
- **`arpa/inet.h`**: Для IP-операций на Unix-подобных системах.

### Платформенные зависимости:
- **Windows**: Требуются `winsock2.h` и `windows.h` для работы с сокетами и системными функциями.
- **Unix-подобные системы**: Требуются `arpa/inet.h` и `unistd.h` для работы с сокетами и системными вызовами.

---

## Константы и определения

### Размеры буферов и ключей:
- **`BUFFER_SIZE`**: Определяет размер буфера для общения (256 байт).
- **`NONCE_SIZE`**: Определяет размер nonce (16 байт).
- **`PRIVATE_KEY_SIZE`**: Определяет размер закрытого ключа для ECC (32 байта).
- **`SHARED_SECRET_SIZE`**: Определяет размер общего секрета (32 байта).

---

## Структуры

### `ClientServerContext`

Структура `ClientServerContext` хранит все необходимые данные для сессии клиент-сервер.

#### Члены структуры:
- **`int portno`**: Номер порта для связи, посему используется int для нормальной работы.
- **`int sockfd`**: Целое число — дескриптор (номер) файла в системе.
- **`struct sockaddr_in serv_addr`**: Структура для адреса сервера(Айпи адрес и порт сервера)
- **`struct hostent *server`**: Информация о сервере для клиента (Айпи адресс сервера и порта).
- **`unsigned char buffer[BUFFER_SIZE]`**: Буфер для отправки/получения данных с размером 256 байтов.
- **`unsigned char bufferlen`**: Размер буфера, который определяется функциями внутри клиента или сервера
- **`unsigned char private_key[PRIVATE_KEY_SIZE]`**: Закрытый ключ сгенерированный при помощи **drng**.
- **`unsigned char shared_secret[SHARED_SECRET_SIZE]`**: Общий ключ для шифрования и дешифрования при помощи ASCON.
- **`unsigned char decrypted_msg[BUFFER_SIZE]`**: Буфер для дешифрованных сообщений.
- **`unsigned long long decrypted_msglen`**: Длина дешифрованного сообщения.
- **`unsigned char *nsec`**: Установлен на NULL, является указателем на дополнительные данные безопасности. НЕ ИСПОЛЬЗУЕТСЯ
- **`unsigned char encrypted_msg[BUFFER_SIZE]`**: Буфер для зашифрованных сообщений.
- **`unsigned long long encrypted_msglen`**: Длина зашифрованного сообщения.
- **`const unsigned char *ad`**: Указатель на "ассоциированные данные" (Associated Data). НЕ ИСПОЛЬЗУЕТСЯ
- **`unsigned long long adlen`**: Длина этих ассоциированных данных. НЕ ИСПОЛЬЗУЕТСЯ
- **`unsigned char npub[NONCE_SIZE]`**: Nonce, является уникальным общим "ключом" для нормального использования ASCON. ОБЯЗАНО БЫТЬ ОДИНАКОВЫМ(Как и общий ключ).
- **`struct sockaddr_in cli_addr`**: Структура для адреса клиента(IP adress, port)
- **`socklen_t clilen`**: Длина адреса клиента для коммуникации с сервером. Использует формат **socklen_t** исключительно для работы с сокетами, тоесть специальный формат.
- **`int newsockfd`**: Сокет для принятых соединений.
---
## Дополнительные переменные
- **`typedef unsigned char uch`**: Предназначена для уменьшения определния **unsigned char** до **uch**
- **`static gf _121665 __attribute__((unused)) = {0xDB41, 1}`**:
    - **static** - предназначен для работы только в рамках Curve25519
    - **gf** - Поле Гаула
    - **_121665** - фиксированное число и название переменной
    - **__attribute__((unused))** - данная команда используется для игнорирования ошибок, которые будут выводить функции, которые не используют данную статическую переменную. Но чтобы данная функция была статическая и не имела проблем в случае вызова в другой функц]()ии
    - **{0xDB41, 1}** - инициализация переменной
- **`static const uch base[32] = {9};`**: Базовая общая точка на Curve25519 для клиента и сервера. Обязательно должна быть идентична
###

## Прототипы функций

### `void initializeContext(ClientServerContext *ctx);`

Инициализирует структуру `ClientServerContext`. Эта функция настраивает все необходимые структуры и буферы для сессии клиента или сервера.

### `void print_hex(uch *data, int length);`

Выводит данные в шестнадцатеричном формате.

### `void error(char *msg);`

Обрабатывает ошибки, обычно выводя сообщение об ошибке и завершая выполнение программы.

### `void generate_private_key(uch private_key[32]);`

Генерирует случайный 256-битный закрытый ключ для ECC.

### `void hexdump(const uch *data, size_t length);`

Выводит дамп данных в шестнадцатеричном формате.

---

## Пользовательские типы

### `typedef unsigned char uch;`

Псевдоним для типа `unsigned char`.

---

## Session.c

## 1. `initializeContext` (Инициализация контекста клиента/сервера)
```c
void initializeContext(ClientServerContext *ctx)
{
ctx->portno = 0;  // Порт не задан
ctx->sockfd = 0;  // Сокет не открыт
memset(&ctx->serv_addr, 0, sizeof(ctx->serv_addr));  // Обнуляем адрес сервера
ctx->optval = 1;  // Опция сокета — разрешить повторное использование адреса

    ctx->server = NULL;  // Указатель на сервер — пока NULL

    memset(ctx->buffer, 0, sizeof(ctx->buffer));  // Очистка буфера обмена
    ctx->bufferlen = 0;  // Длина буфера — 0

    memset(ctx->client_public_key, 0, sizeof(ctx->client_public_key));  // Очистка публичного ключа клиента
    memset(ctx->server_public_key, 0, sizeof(ctx->server_public_key));  // Очистка публичного ключа сервера
    memset(ctx->private_key, 0, sizeof(ctx->private_key));              // Очистка приватного ключа
    memset(ctx->shared_secret, 0, sizeof(ctx->shared_secret));          // Очистка общего секрета
    memset(ctx->decrypted_msg, 0, sizeof(ctx->decrypted_msg));          // Очистка буфера расшифрованных данных
    ctx->decrypted_msglen = 0;                                          // Длина расшифрованных данных = 0

    ctx->nsec = NULL;  // Указатель на nonce-параметр безопасности = NULL

    memset(ctx->encrypted_msg, 0, sizeof(ctx->encrypted_msg));  // Очистка буфера зашифрованных данных
    ctx->encrypted_msglen = 0;                                  // Длина зашифрованных данных = 0

    // Устанавливаем фиксированное значение nonce для тестов (небезопасно в продакшене)
    memcpy(ctx->npub, "simple_nonce_123", NONCE_SIZE);
}
```
- Функция настраивает структуру ClientServerContext в начальное состояние.

- Используется перед любыми сетевыми или криптографическими операциями.

- Все поля обнуляются, чтобы исключить мусорные значения.

## 2. `hexdump` (Вывод байтов в hex-формате)
```c
void hexdump(const uch *data, size_t length)
{
printf("\n");
for (size_t i = 0; i < length; i++) {
printf("%02x", data[i]);  // Печать байта в hex

        if ((i + 1) % 16 == 0)
            printf("\n");  // Перенос строки после каждых 16 байт
    }

    if (length % 16 != 0)
        printf("\n");  // Последний перенос строки, если нужно

    printf("\n");
}
```
- Удобная вспомогательная функция для отладки: печатает любые данные в hex.

- Разбивает вывод по 16 байт, чтобы глаз легче читал.

- Используется, например, при выводе ключей или шифротекста.

## 3. generate_private_key (Генерация приватного ключа длиной 32 байта)
```c
void generate_private_key(uch private_key[32])
{
if (rdrand_get_bytes(32, (unsigned char *) private_key) < 32) {
error("Random values not available");  // Ошибка генерации
}
    printf("Private key: \n");
    hexdump(private_key, 32);  // Выводим сгенерированный ключ в hex-формате
}
```

- Генерирует криптографически безопасный приватный ключ длиной 256 бит (32 байта).

- Использует аппаратную функцию rdrand — генератор случайных чисел от Intel.

- Если rdrand не работает или возвращает недостаточно байт — вызывается error() (некорректное завершение).

- Выводит ключ на экран (подходит для отладки, не для продакшена).