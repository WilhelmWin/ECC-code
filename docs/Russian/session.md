# Документация для файла Session

## Обзор

Данный раздел предназначен для объяснения кода **`session.h`** и **`session.c`**

### Основные особенности данного кода:
- Содержит системные библиотеки С
- Содержит специальные библиотеки Windows и Linux для сокетов
- Объявление размеров при помощи define
- Структуру со всеми переменными используемые клиентом и сервером
- Функцию для инициализации структуры
- Функцию для вывода ключей в шестнадцатеричном формате.
- Функцию вывода ошибок
- Функцию генерации ключей с вызовом функции с файла drng
- Функцию вывода дамп данных 

## Файл: `session.h`

### Используемые библиотеки:
- **`netinet/in.h`**: Для структур и функций сокетов на Unix-подобных системах.
- **`sys/types.h`, `sys/socket.h`, `unistd.h`**: Для работы с сокетами и системных вызовов на Unix-подобных системах.
- **`stdint.h`**: Для типов фиксированной ширины, таких как `uint8_t`.
- **`ECC.h`**: Библиотека для Curve25519.
- **`ASCON/crypto_aead.h`**: Библиотека для работы с ASCON
- **`string.h`**: Для строковых функций (например, `memset()`, `memcpy()`).
- **`stdio.h`**: Для стандартных функций ввода/вывода (например, `printf()`).
- **`stdlib.h`**: Для стандартных функций библиотеки (например, `malloc()`).
- **`winsock2.h`**: Для работы с сокетами в Windows.
- **`arpa/inet.h`**: Для IP-операций на Unix-подобных системах.

### Платформенные зависимости:
- **Windows**: Требуются `winsock2.h` и `windows.h` для работы с сокетами и системными функциями.
- **Unix-подобные системы**: Требуются `arpa/inet.h` и `unistd.h` для работы с сокетами и системными вызовами.

---

## Константы и определения

### Размеры буферов и ключей:
- **`BUFFER_SIZE`**: Определяет размер буфера для общения (256 байт).
- **`NONCE_SIZE`**: Определяет размер nonce (16 байт).
- **`PRIVATE_KEY_SIZE`**: Определяет размер закрытого ключа для ECC (32 байта).
- **`SHARED_SECRET_SIZE`**: Определяет размер общего секрета (32 байта).

---

## Структуры

### `ClientServerContext`

Структура `ClientServerContext` хранит все необходимые данные для сессии клиент-сервер.

#### Члены структуры:
- **`int portno`**: Номер порта для связи, посему используется int для нормальной работы. 
- **`int sockfd`**: Целое число — дескриптор (номер) файла в системе.
- **`struct sockaddr_in serv_addr`**: Структура для адреса сервера(Айпи адрес и порт сервера)
- **`struct hostent *server`**: Информация о сервере для клиента (Айпи адресс сервера и порта).
- **`unsigned char buffer[BUFFER_SIZE]`**: Буфер для отправки/получения данных с размером 256 байтов.
- **`unsigned char bufferlen`**: Размер буфера, который определяется функциями внутри клиента или сервера
- **`unsigned char private_key[PRIVATE_KEY_SIZE]`**: Закрытый ключ сгенерированный при помощи **drng**.
- **`unsigned char shared_secret[SHARED_SECRET_SIZE]`**: Общий ключ для шифрования и дешифрования при помощи ASCON.
- **`unsigned char decrypted_msg[BUFFER_SIZE]`**: Буфер для дешифрованных сообщений.
- **`unsigned long long decrypted_msglen`**: Длина дешифрованного сообщения.
- **`unsigned char *nsec`**: Установлен на NULL, является указателем на дополнительные данные безопасности. НЕ ИСПОЛЬЗУЕТСЯ
- **`unsigned char encrypted_msg[BUFFER_SIZE]`**: Буфер для зашифрованных сообщений.
- **`unsigned long long encrypted_msglen`**: Длина зашифрованного сообщения.
- **`const unsigned char *ad`**: Указатель на "ассоциированные данные" (Associated Data). НЕ ИСПОЛЬЗУЕТСЯ
- **`unsigned long long adlen`**: Длина этих ассоциированных данных. НЕ ИСПОЛЬЗУЕТСЯ
- **`unsigned char npub[NONCE_SIZE]`**: Nonce, является уникальным общим "ключом" для нормального использования ASCON. ОБЯЗАНО БЫТЬ ОДИНАКОВЫМ(Как и общий ключ).
- **`struct sockaddr_in cli_addr`**: Структура для адреса клиента(IP adress, port)
- **`socklen_t clilen`**: Длина адреса клиента для коммуникации с сервером. Использует формат **socklen_t** исключительно для работы с сокетами, тоесть специальный формат.
- **`int newsockfd`**: Сокет для принятых соединений.
---
## Дополнительные переменные 
- **`typedef unsigned char uch`**: Предназначена для уменьшения определния **unsigned char** до **uch**
- **`static gf _121665 __attribute__((unused)) = {0xDB41, 1}`**:
  - **static** - предназначен для работы только в рамках Curve25519
  - **gf** - Поле Гаула 
  - **_121665** - фиксированное число и название переменной
  - **__attribute__((unused))** - данная команда используется для игнорирования ошибок, которые будут выводить функции, которые не используют данную статическую переменную. Но чтобы данная функция была статическая и не имела проблем в случае вызова в другой функц]()ии 
  - **{0xDB41, 1}** - инициализация переменной 
- **`static const uch base[32] = {9};`**: Базовая общая точка на Curve25519 для клиента и сервера. Обязательно должна быть идентична
###

## Прототипы функций

### `void initializeContext(ClientServerContext *ctx);`

Инициализирует структуру `ClientServerContext`. Эта функция настраивает все необходимые структуры и буферы для сессии клиента или сервера.

### `void print_hex(uch *data, int length);`

Выводит данные в шестнадцатеричном формате.

### `void error(char *msg);`

Обрабатывает ошибки, обычно выводя сообщение об ошибке и завершая выполнение программы.

### `void generate_private_key(uch private_key[32]);`

Генерирует случайный 256-битный закрытый ключ для ECC.

### `void hexdump(const uch *data, size_t length);`

Выводит дамп данных в шестнадцатеричном формате.

---

## Пользовательские типы

### `typedef unsigned char uch;`

Псевдоним для типа `unsigned char`.

---

## Session.c

```c
#include "session.h" // Основная библитеотека для коммуникации с внешним миром
#include "drng.h" //Для генерации приватного ключа

// ========================================================================
// Функция для инициализации контекста для связи клиент-сервер
// ========================================================================
void initializeContext(ClientServerContext *ctx) {
    // Инициализация номера порта значением 0 (порт еще не установлен)
    ctx->portno = 0;

    // Инициализация дескриптора сокета значением 0 (сокет еще не открыт)
    ctx->sockfd = 0;

    // Обнуление структуры адреса сервера
    memset(&ctx->serv_addr, 0, sizeof(ctx->serv_addr));

    // Установка указателя на сервер в NULL (сервер еще не установлен)
    ctx->server = NULL;

    // Обнуление буфера, используемого для связи
    memset(ctx->buffer, 0, sizeof(ctx->buffer));

    // Установка длины буфера в 0
    ctx->bufferlen = 0;

    // Обнуление приватного ключа
    // (он будет использоваться для криптографических операций)
    memset(ctx->private_key, 0, sizeof(ctx->private_key));

    // Обнуление общего секрета (используется для шифрования и дешифрования)
    memset(ctx->shared_secret, 0, sizeof(ctx->shared_secret));

    // Обнуление буфера расшифрованного сообщения
    memset(ctx->decrypted_msg, 0, sizeof(ctx->decrypted_msg));

    // Инициализация длины расшифрованного сообщения в 0
    ctx->decrypted_msglen = 0;

    // Установка параметра безопасности nonce в NULL
    ctx->nsec = NULL;

    // Обнуление буфера зашифрованного сообщения
    memset(ctx->encrypted_msg, 0, sizeof(ctx->encrypted_msg));

    // Инициализация длины зашифрованного сообщения в 0
    ctx->encrypted_msglen = 0;

    // Установка ассоциированных данных (ad) в NULL
    ctx->ad = NULL;

    // Инициализация длины ассоциированных данных в 0
    ctx->adlen = 0;

    // Установка фиксированного значения для nonce (используется для уникальности шифрования)
    memcpy(ctx->npub, "simple_nonce_123", NONCE_SIZE);
}

// ========================================================================
// Функция для вывода данных в шестнадцатеричном формате
// ========================================================================
void hexdump(const uch *data, size_t length) {
    // Итерация по каждому байту в переданных данных
    for (size_t i = 0; i < length; i++) {
        // Вывод байта в шестнадцатеричном формате
        printf("%02x", data[i]);

        // Добавление новой строки после каждых 16 байт для удобства
        if ((i + 1) % 16 == 0)
            printf("\n");
    }

    // Обеспечение вывода с новой строки, если длина данных не кратна 16
    if (length % 16 != 0)
        printf("\n");
}

// ====================================================
// Функция для генерации случайного приватного ключа (256 бит / 32 байта)
// ====================================================
void generate_private_key(uch private_key[32]) {
    // Пытаемся получить 32 байта случайных данных с помощью rdrand
    // (генератор случайных чисел)
    // Если количество полученных байт меньше 32, выводим ошибку
    if (rdrand_get_bytes(32, (unsigned char *) private_key) < 32) {
        // Обработка ошибки, если не удалось получить случайные данные
        fprintf(stderr, "Random values not available\n");
        return;  // Выход из функции, если случайные данные недоступны
    }

    // Вывод сгенерированного приватного ключа в шестнадцатеричном формате
    printf("rdrand128:\n");
    hexdump(private_key, 32);  // Вызов функции для вывода приватного ключа в hex формате
}

// ========================================================================
// Функция для обработки ошибок, выводя сообщение об ошибке и завершая программу
// ========================================================================
void error(char *msg) {
    perror(msg);  // Вывод сообщения об ошибке с помощью perror
    exit(1);  // Завершаем программу с кодом ошибки 1
}

// ========================================================================
// Функция для вывода заданного массива данных в шестнадцатеричном формате
// ========================================================================
void print_hex(uch *data, int length) {
    // Итерация по массиву данных и вывод каждого байта в
    // шестнадцатеричном формате
    for (int i = 0; i < length; i++) {
        printf("%02X", data[i]);
    }
    // Вывод новой строки после вывода всех данных
    printf("\n");
}

