# Документация: Сервер защищённого обмена сообщениями
## 1. Описание

Этот модуль реализует защищённый сервер, предназначенный 
для безопасного обмена сообщениями с клиентом. Обмен 
сообщениями происходит по протоколу TCP с использованием 
шифрования на основе симметричного ключа, полученного через 
алгоритм Диффи-Хеллмана и созданный при помощи Curve25519. 
Шифрование и дешифрование данных происходит с помощью ASCON128a
и общего ключа.
Дополнительно обеспечивается кроссплатформенная 
совместимость (Windows и Linux).
## 2. Использование
```c
./server <port>
```
- `<port>` — номер порта, на котором сервер будет прослушивать входящие соединения.

## 3. Ключевые особенности

- Кроссплатформенная инициализация сокетов.

- Проверка аргументов командной строки.

- Генерация приватного ключа.

- Реализация Диффи-Хеллмана для создания общего секрета.

- Приём и передача зашифрованных сообщений.

- Обработка завершения соединения по команде bye.

- Обработка системных сигналов (`SIGINT`, `SIGTERM`, `SIGTSTP`).

- Аудио сопровождение при запуске (опционально).

## 4. Структура ClientServerContext

| Поле | Описание |
|------|----------|
| `sockfd` | Дескриптор серверного сокета |
| `newsockfd` | Дескриптор сокета соединения с клиентом |
| `portno` | Номер порта |
| `serv_addr` | Структура с адресом сервера |
| `cli_addr` | Структура с адресом клиента |
| `clilen` | Размер структуры `cli_addr` |
| `optval` | Параметр для `setsockopt` |
| `private_key[32]` | Приватный ключ сервера |
| `public_key[32]` | Публичный ключ сервера |
| `client_public_key[32]` | Публичный ключ клиента |
| `shared_secret[32]` | Общий секрет, полученный по DH |
| `buffer[BUFFER_SIZE]` | Буфер для текстовых сообщений |
| `bufferlen` | Длина содержимого буфера |
| `encrypted_msg[BUFFER_SIZE + 16]` | Зашифрованное сообщение |
| `encrypted_msglen` | Длина зашифрованного сообщения |
| `decrypted_msg[BUFFER_SIZE]` | Расшифрованное сообщение |
| `decrypted_msglen` | Длина расшифрованного сообщения |
| `npub[NONCE_SIZE]` | Нонс |
| `nsec[NONCE_SIZE]` | Дополнительная секция безопасности (не используется) |

## 5. Основные этапы выполнения
### 5.1. Инициализация

- Создание структуры ClientServerContext

- Windows: инициализация `Winsock` (WSAStartup)

- Проверка аргументов командной строки

### 5.2. Создание и настройка сокета

- Создание TCP-сокета через `socket()`

- Настройка `SO_REUSEADDR`

- Привязка адреса с помощью `bind()`

- Установка прослушивания соединений через `listen()`

### 5.3. Обработка сигналов

- Windows: `register_signal_handler(&ctx)`

- Linux: регистрация через `sigaction()`

### 5.4. Принятие соединения

- Ожидание клиента через `accept()`

- Запуск фоновой музыки The Hunter.wav

## 6. Обмен ключами (Diffie-Hellman)

- Генерация приватного и публичного ключей с использованием `crypto_scalarmult_base()`

- Отправка публичного ключа клиенту

- Получение публичного ключа клиента

- Вычисление общего секрета через `crypto_scalarmult()`

- Отладочная печать с помощью `hexdump()`

## 7. Цикл общения

- Чтение зашифрованного сообщения от клиента (`recv()` / `read()`)

- Расшифровка с помощью `crypto_aead_decrypt()`

- Проверка на завершение общения (`strcasecmp("bye")`)

- Получение ответа от пользователя (`fgets()`)

- Удаление символа новой строки

- Шифрование с помощью `crypto_aead_encrypt()`

- Отправка зашифрованного сообщения клиенту

- Выход при вводе bye

## 8. Завершение работы

- Закрытие сокетов (`closesocket()` / `close()`)

- Windows: освобождение ресурсов Winsock через W`SACleanup()`

## 9. Обработка ошибок

- Все критические участки обернуты в проверки с вызовом `error_server()` или `error()`

- Сообщения включают пояснения о контексте ошибки

- В случае ошибки ресурсы корректно освобождаются

## 10. Вспомогательные функции
### `initializeContext(ClientServerContext *ctx)`

- Инициализирует поля структуры по умолчанию.
### `error(const char *msg)`

- Печатает сообщение об ошибке и завершает выполнение.
### `error_server(const char *msg, int sockfd, int newsockfd)`

- Закрывает сокеты и завершает выполнение с сообщением об ошибке.
### `generate_private_key(uint8_t *private_key)`

- Генерирует случайный 32-байтовый приватный ключ.
### `hexdump(uint8_t *data, size_t len)`

- Выводит содержимое буфера в шестнадцатеричном виде.
### `play_music(const char *filename, int loop)`

- Воспроизводит музыку при запуске сервера.
## 11. Пример вывода
```c
Generated private key for server:
5a 1d ef 24 ... b9 33
Connection accepted
Received client's public key:
1f 3b 5c ... d2 ef
Shared secret key:
a8 7d c1 ... 99 01
Client: Hello!
Me: Hello back!
```
---

## 13. Описание основных частей кода
### 13.1. Инициализация контекста
```c
ClientServerContext ctx;
initializeContext(&ctx);
```
#### Назначение:
- Создаётся структура `ctx`, содержащая всё состояние сервера.
Функция `initializeContext()` обнуляет поля и подготавливает структуру
к дальнейшему использованию.
### 13.2. Инициализация `Winsock` (только для Windows)
```c
#ifdef _WIN32
WSADATA wsaData;
if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
error("WSAStartup failed");
}
#endif
```
#### Назначение:
- На Windows необходимо вручную инициализировать сетевой стек с
помощью `WSAStartup()`. Без этого нельзя использовать сокеты.

### 13.3. Обработка аргументов командной строки
```c
if (argc < 2) {
error("Missing port\nServer usage format:\n./server <port>");
}
if (argc >= 3) {
error("Too many arguments\nServer usage format:\n./server <port>");
}
ctx.portno = atoi(argv[1]);
```
#### Назначение:
- Проверка корректности переданных аргументов. Ожидается ровно один аргумент — порт.
Если аргументов меньше или больше — программа завершает работу с сообщением.
### 13.4. Генерация приватного ключа
```c
generate_private_key(ctx.private_key);
printf("Generated private key for server:\n");
hexdump(ctx.private_key, 32);
```
#### Назначение:
- Создаётся случайный приватный ключ сервера (32 байта),
необходимый для дальнейшего криптографического обмена по Диффи-Хеллману.
### 13.5. Создание сокета
```c
ctx.sockfd = socket(AF_INET, SOCK_STREAM, 0);
```
#### Назначение:
- Создание TCP-сокета для приёма входящих соединений. 
Обрабатываются ошибки в зависимости от платформы.
### 13.6. Настройка адреса и привязка
```c
memset(&ctx.serv_addr, 0, sizeof(ctx.serv_addr));
ctx.serv_addr.sin_family = AF_INET;
ctx.serv_addr.sin_addr.s_addr = INADDR_ANY;
ctx.serv_addr.sin_port = htons(ctx.portno);

setsockopt(...);
bind(ctx.sockfd, (struct sockaddr *)&ctx.serv_addr, sizeof(ctx.serv_addr));
```
#### Назначение:
- Подготовка структуры адреса, установка флага `SO_REUSEADDR` и 
привязка сокета к выбранному порту.
### 13.7. Прослушивание подключений
```c
listen(ctx.sockfd, 5);
```
#### Назначение:
Перевод сокета в режим прослушивания. Максимум 5 ожидающих соединений в очереди.
### 13.8. Обработка сигналов (Ctrl+C, Ctrl+Z и пр.)
```c
#ifdef _WIN32
register_signal_handler(&ctx);
#else
struct sigaction sa;
sa.sa_flags = SA_SIGINFO;
sa.sa_sigaction = handle_signal;
sigaction(SIGINT, &sa, NULL);
...
#endif
```
#### Назначение:
- Обеспечивает корректное завершение работы сервера при получении 
системных сигналов (например, SIGINT при нажатии Ctrl+C).
### 13.9. Принятие соединения
```c
ctx.newsockfd = accept(ctx.sockfd, (struct sockaddr *)&ctx.cli_addr, &ctx.clilen);
```
#### Назначение:
- Принятие соединения от клиента. Возвращает дескриптор нового сокета,
по которому будет происходить дальнейшее общение.
### 13.10. Запуск фоновой музыки (необязательная часть)
```c
play_music("The Hunter.wav", -1);
```
#### Назначение:
- Атмосферная опция. Запускает воспроизведение аудиофайла при старте сервера. 
Поддерживается как на Windows, так и Linux.
### 13.11. Обмен ключами (Диффи-Хеллман)
```c
crypto_scalarmult_base(ctx.public_key, ctx.private_key);
send(ctx.newsockfd, ctx.public_key, ...);
recv(ctx.newsockfd, ctx.client_public_key, ...);
crypto_scalarmult(ctx.shared_secret, ctx.private_key, ctx.client_public_key);
```
#### Назначение:
- Реализация алгоритма Диффи-Хеллмана:
  1. Генерация публичного ключа на основе приватного. 
  2. Отправка публичного ключа клиенту. 
  3. Получение ключа клиента. 
  4. Вычисление общего секрета.

### 13.12. Цикл общения (чтение → расшифровка → ответ → шифрование)
```c
while (1) {
recv(...); // получение зашифрованного сообщения
crypto_aead_decrypt(...); // расшифровка
printf("Client: %s\n", ...); // вывод сообщения

    if (strcasecmp(..., "bye") == 0) break;

    fgets(...); // ввод ответа от сервера
    crypto_aead_encrypt(...); // шифрование ответа
    send(...); // отправка клиенту
}
```
#### Назначение:

- Получение и расшифровка сообщений клиента.

- Ответ сервера в зашифрованном виде.

- Выход из цикла, если получено или введено `"bye"`.

### 13.13. Завершение работы
```c
closesocket() / close()
WSACleanup()
```
#### Назначение:
- Корректное закрытие сокетов и очистка ресурсов перед завершением работы программы.

## 14. Архитектура взаимодействия (блок-схема)

Ниже представлена логическая последовательность 
обработки соединения и сообщений между сервером и клиентом:

```text
        ┌─────────────────────────────────────────────────────┐
        │                 Старт программы                     │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │     Проверка аргументов и инициализация контекста   │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │     Инициализация сокета и привязка к порту         │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │     Прослушивание входящих соединений               │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │     Принятие соединения от клиента                  │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │   Обмен публичными ключами (Диффи-Хеллман)          │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │   Вычисление общего секрета                         │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │   Цикл общения (шифрование/дешифрование сообщений)  │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │   Обработка команд (например, "bye")                │
        └─────────────────────────────────────────────────────┘
                                 │
                                 ▼
        ┌─────────────────────────────────────────────────────┐
        │   Завершение работы, очистка ресурсов               │
        └─────────────────────────────────────────────────────┘
```

## 15. Основные ошибки и их обработка

Программа реализует собственную систему сообщений об ошибках с
использованием функции `error()` и `error_server()`, которая дополнительно 
освобождает ресурсы.

| Ошибка                                              | Причина                                             | Поведение                                   |
|-----------------------------------------------------|------------------------------------------------------|---------------------------------------------|
| `WSAStartup failed`                                 | Winsock не инициализирован                          | Завершение работы                           |
| `Missing port`, `Too many arguments`                | Неверное число аргументов                           | Завершение работы                           |
| `ERROR opening socket`                              | Ошибка при создании сокета                          | Завершение работы                           |
| `ERROR on binding`                                  | Ошибка привязки сокета                              | Завершение работы                           |
| `ERROR on listen`                                   | Невозможно слушать сокет                            | Завершение работы                           |
| `ERROR on accept`                                   | Ошибка при принятии клиента                         | Завершение работы                           |
| `Error sending public key`                          | Не удалось отправить ключ                           | Завершение работы                           |
| `Error receiving public key`                        | Не удалось получить ключ                            | Завершение работы                           |
| `Decryption error`                                  | Ошибка расшифровки сообщения                        | Завершение работы                           |
| `Encryption error`                                  | Ошибка при шифровании сообщения                     | Завершение работы                           |
| `Error reading from client`, `Error writing to client` | Ошибки при обмене сообщениями                      | Завершение работы                           |
| `Error reading input`                               | Ошибка чтения ввода с консоли сервера               | Завершение работы                           |
## 16. Безопасность

### Программа использует:

- Алгоритм Диффи-Хеллмана для безопасного обмена ключами.

- AEAD (Authenticated Encryption with Associated Data) — для шифрования/дешифрования 
сообщений.

- 32-байтные ключи, безопасно генерируемые с помощью `generate_private_key()`.

- Использование уникальных `nonce`/`iv` в каждом сообщении через `ctx.npub`.

Вся коммуникация после установки соединения полностью зашифрована и аутентифицирована.
## 17. Платформенная кросс-компатибельность

### Код адаптирован для:

- Windows: с использованием `WSAStartup`, `closesocket`, `INVALID_SOCKET`, `PlaySound`.

- Unix/Linux: с использованием POSIX-функций `socket`, `bind`, `listen`, `read`, 
`write`, `close`, `sigaction`.

- Использование директив `#ifdef _WIN32` обеспечивает сборку
одного исходного файла на обеих платформах.
# Заключение

### Данный сервер реализует:

- Безопасное подключение клиента.

- Шифрование всех передаваемых данных.

- Возможность общения в режиме реального времени.

- Кросс-платформенность и обработку системных сигналов.

- Структурированную обработку ошибок.

### Код легко масштабируется: 
- Можно добавить логирование, аутентификацию, многопоточность или GUI-интерфейс.