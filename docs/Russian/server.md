Документация: Сервер защищённого обмена сообщениями
1. Назначение

Этот модуль реализует защищённый сервер, предназначенный для безопасного обмена сообщениями с клиентом. Обмен сообщениями происходит по протоколу TCP с использованием шифрования на основе симметричного ключа, полученного через алгоритм Диффи-Хеллмана. Дополнительно обеспечивается кроссплатформенная совместимость (Windows и Linux).
2. Использование

./server <port>

    <port> — номер порта, на котором сервер будет прослушивать входящие соединения.

3. Основные возможности

   Кроссплатформенная инициализация сокетов.

   Проверка аргументов командной строки.

   Генерация приватного ключа.

   Реализация Диффи-Хеллмана для создания общего секрета.

   Приём и передача зашифрованных сообщений.

   Обработка завершения соединения по команде bye.

   Обработка системных сигналов (SIGINT, SIGTERM, SIGTSTP).

   Аудио сопровождение при запуске (опционально).

4. Структура ClientServerContext

ClientServerContext — структура, инкапсулирующая всё состояние сервера:
Поле	Описание
sockfd	Дескриптор серверного сокета
newsockfd	Дескриптор сокета соединения с клиентом
portno	Номер порта
serv_addr	Структура с адресом сервера
cli_addr	Структура с адресом клиента
clilen	Размер структуры cli_addr
optval	Параметр для setsockopt
private_key[32]	Приватный ключ сервера
public_key[32]	Публичный ключ сервера
client_public_key[32]	Публичный ключ клиента
shared_secret[32]	Общий секрет, полученный по DH
buffer[BUFFER_SIZE]	Буфер для текстовых сообщений
bufferlen	Длина содержимого буфера
encrypted_msg[BUFFER_SIZE + 16]	Зашифрованное сообщение
encrypted_msglen	Длина зашифрованного сообщения
decrypted_msg[BUFFER_SIZE]	Расшифрованное сообщение
decrypted_msglen	Длина расшифрованного сообщения
npub[NONCE_SIZE]	Нонс
nsec[NONCE_SIZE]	Дополнительная секция безопасности (не используется)
5. Основные этапы выполнения
   5.1. Инициализация

   Создание структуры ClientServerContext

   Windows: инициализация Winsock (WSAStartup)

   Проверка аргументов командной строки

5.2. Создание и настройка сокета

    Создание TCP-сокета через socket()

    Настройка SO_REUSEADDR

    Привязка адреса с помощью bind()

    Установка прослушивания соединений через listen()

5.3. Обработка сигналов

    Windows: register_signal_handler(&ctx)

    Linux: регистрация через sigaction()

5.4. Принятие соединения

    Ожидание клиента через accept()

    Запуск фоновой музыки The Hunter.wav

6. Обмен ключами (Diffie-Hellman)

   Генерация приватного и публичного ключей с использованием crypto_scalarmult_base()

   Отправка публичного ключа клиенту

   Получение публичного ключа клиента

   Вычисление общего секрета через crypto_scalarmult()

   Отладочная печать с помощью hexdump()

7. Цикл общения

   Чтение зашифрованного сообщения от клиента (recv() / read())

   Расшифровка с помощью crypto_aead_decrypt()

   Проверка на завершение общения (strcasecmp("bye"))

   Получение ответа от пользователя (fgets())

   Удаление символа новой строки

   Шифрование с помощью crypto_aead_encrypt()

   Отправка зашифрованного сообщения клиенту

   Выход при вводе bye

8. Завершение работы

   Закрытие сокетов (closesocket() / close())

   Windows: освобождение ресурсов Winsock через WSACleanup()

9. Обработка ошибок

   Все критические участки обернуты в проверки с вызовом error_server() или error()

   Сообщения включают пояснения о контексте ошибки

   В случае ошибки ресурсы корректно освобождаются

10. Вспомогательные функции
    initializeContext(ClientServerContext *ctx)

Инициализирует поля структуры по умолчанию.
error(const char *msg)

Печатает сообщение об ошибке и завершает выполнение.
error_server(const char *msg, int sockfd, int newsockfd)

Закрывает сокеты и завершает выполнение с сообщением об ошибке.
generate_private_key(uint8_t *private_key)

Генерирует случайный 32-байтовый приватный ключ.
hexdump(uint8_t *data, size_t len)

Выводит содержимое буфера в шестнадцатеричном виде.
play_music(const char *filename, int loop)

Воспроизводит музыку при запуске сервера.
11. Пример вывода

Generated private key for server:
5a 1d ef 24 ... b9 33
Connection accepted
Received client's public key:
1f 3b 5c ... d2 ef
Shared secret key:
a8 7d c1 ... 99 01
Client: Hello!
Me: Hello back!

12. Требуемые зависимости

    libsodium — для криптографических операций (crypto_scalarmult, crypto_aead_*)

    SDL2_mixer или PlaySound() — для воспроизведения аудио

    Стандартные заголовки: <stdio.h>, <stdlib.h>, <string.h>, <signal.h>, <unistd.h>, <winsock2.h>, <ws2tcpip.h> и т.д.

Если нужно, могу также оформить это в PDF, Markdown или встроить в Doxygen-документ. Хотите?
You said:
Продолжай документацию, теперь опиши части кодов, основные
ChatGPT said:

Конечно! Ниже продолжается документация с подробным описанием основных частей кода — ключевых логических блоков программы, их роли и взаимодействия между собой.
13. Описание основных частей кода
    13.1. Инициализация контекста

ClientServerContext ctx;
initializeContext(&ctx);

Назначение:
Создаётся структура ctx, содержащая всё состояние сервера. Функция initializeContext() обнуляет поля и подготавливает структуру к дальнейшему использованию.
13.2. Инициализация Winsock (только для Windows)

#ifdef _WIN32
WSADATA wsaData;
if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
error("WSAStartup failed");
}
#endif

Назначение:
На Windows необходимо вручную инициализировать сетевой стек с помощью WSAStartup(). Без этого нельзя использовать сокеты.
13.3. Обработка аргументов командной строки

if (argc < 2) {
error("Missing port\nServer usage format:\n./server <port>");
}
if (argc >= 3) {
error("Too many arguments\nServer usage format:\n./server <port>");
}
ctx.portno = atoi(argv[1]);

Назначение:
Проверка корректности переданных аргументов. Ожидается ровно один аргумент — порт. Если аргументов меньше или больше — программа завершает работу с сообщением.
13.4. Генерация приватного ключа

generate_private_key(ctx.private_key);
printf("Generated private key for server:\n");
hexdump(ctx.private_key, 32);

Назначение:
Создаётся случайный приватный ключ сервера (32 байта), необходимый для дальнейшего криптографического обмена по Диффи-Хеллману.
13.5. Создание сокета

ctx.sockfd = socket(AF_INET, SOCK_STREAM, 0);

Назначение:
Создание TCP-сокета для приёма входящих соединений. Обрабатываются ошибки в зависимости от платформы.
13.6. Настройка адреса и привязка

memset(&ctx.serv_addr, 0, sizeof(ctx.serv_addr));
ctx.serv_addr.sin_family = AF_INET;
ctx.serv_addr.sin_addr.s_addr = INADDR_ANY;
ctx.serv_addr.sin_port = htons(ctx.portno);

setsockopt(...);
bind(ctx.sockfd, (struct sockaddr *)&ctx.serv_addr, sizeof(ctx.serv_addr));

Назначение:
Подготовка структуры адреса, установка флага SO_REUSEADDR и привязка сокета к выбранному порту.
13.7. Прослушивание подключений

listen(ctx.sockfd, 5);

Назначение:
Перевод сокета в режим прослушивания. Максимум 5 ожидающих соединений в очереди.
13.8. Обработка сигналов (Ctrl+C, Ctrl+Z и пр.)

#ifdef _WIN32
register_signal_handler(&ctx);
#else
struct sigaction sa;
sa.sa_flags = SA_SIGINFO;
sa.sa_sigaction = handle_signal;
sigaction(SIGINT, &sa, NULL);
...
#endif

Назначение:
Обеспечивает корректное завершение работы сервера при получении системных сигналов (например, SIGINT при нажатии Ctrl+C).
13.9. Принятие соединения

ctx.newsockfd = accept(ctx.sockfd, (struct sockaddr *)&ctx.cli_addr, &ctx.clilen);

Назначение:
Принятие соединения от клиента. Возвращает дескриптор нового сокета, по которому будет происходить дальнейшее общение.
13.10. Запуск фоновой музыки (необязательная часть)

play_music("The Hunter.wav", -1);

Назначение:
Атмосферная опция. Запускает воспроизведение аудиофайла при старте сервера. Поддерживается как на Windows, так и Linux.
13.11. Обмен ключами (Диффи-Хеллман)

crypto_scalarmult_base(ctx.public_key, ctx.private_key);
send(ctx.newsockfd, ctx.public_key, ...);
recv(ctx.newsockfd, ctx.client_public_key, ...);
crypto_scalarmult(ctx.shared_secret, ctx.private_key, ctx.client_public_key);

Назначение:
Реализация алгоритма Диффи-Хеллмана:

    Генерация публичного ключа на основе приватного.

    Отправка публичного ключа клиенту.

    Получение ключа клиента.

    Вычисление общего секрета.

13.12. Цикл общения (чтение → расшифровка → ответ → шифрование)

while (1) {
recv(...); // получение зашифрованного сообщения
crypto_aead_decrypt(...); // расшифровка
printf("Client: %s\n", ...); // вывод сообщения

    if (strcasecmp(..., "bye") == 0) break;

    fgets(...); // ввод ответа от сервера
    crypto_aead_encrypt(...); // шифрование ответа
    send(...); // отправка клиенту
}

Назначение:

    Получение и расшифровка сообщений клиента.

    Ответ сервера в зашифрованном виде.

    Выход из цикла, если получено или введено "bye".

13.13. Завершение работы

closesocket() / close()
WSACleanup()

Назначение:
Корректное закрытие сокетов и очистка ресурсов перед завершением работы программы.

Если вы хотите, я могу далее привести краткую блок-схему архитектуры взаимодействия, таблицу ошибок, или оформить всё это в виде .md или .pdf файла. Хотите продолжить?
You said:
Давай дальше
ChatGPT said:

Отлично! Продолжим документацию. Теперь опишем:
14. Архитектура взаимодействия (блок-схема)

Ниже представлена логическая последовательность обработки соединения и сообщений между сервером и клиентом:

┌─────────────────────────────────────────────────────┐
│                 Старт программы                     │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│     Проверка аргументов и инициализация контекста   │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│     Инициализация сокета и привязка к порту         │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│     Прослушивание входящих соединений               │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│     Принятие соединения от клиента                  │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│   Обмен публичными ключами (Диффи-Хеллман)          │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│   Вычисление общего секрета                         │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│   Цикл общения (шифрование/дешифрование сообщений)  │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│   Обработка команд (например, "bye")                │
└─────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────┐
│   Завершение работы, очистка ресурсов               │
└─────────────────────────────────────────────────────┘

15. Основные ошибки и их обработка

Программа реализует собственную систему сообщений об ошибках с использованием функции error() и error_server(), которая дополнительно освобождает ресурсы.
Ошибка	Причина	Поведение
WSAStartup failed	Winsock не инициализирован	Завершение работы
Missing port, Too many arguments	Неверное число аргументов	Завершение работы
ERROR opening socket	Ошибка при создании сокета	Завершение работы
ERROR on binding	Ошибка привязки сокета	Завершение работы
ERROR on listen	Невозможно слушать сокет	Завершение работы
ERROR on accept	Ошибка при принятии клиента	Завершение работы
Error sending public key	Не удалось отправить ключ	Завершение работы
Error receiving public key	Не удалось получить ключ	Завершение работы
Decryption error	Ошибка расшифровки сообщения	Завершение работы
Encryption error	Ошибка при шифровании сообщения	Завершение работы
Error reading from client, Error writing to client	Ошибки при обмене сообщениями	Завершение работы
Error reading input	Ошибка чтения ввода с консоли сервера	Завершение работы
16. Безопасность

Программа использует:

    Алгоритм Диффи-Хеллмана для безопасного обмена ключами.

    AEAD (Authenticated Encryption with Associated Data) — для шифрования/дешифрования сообщений.

    32-байтные ключи, безопасно генерируемые с помощью generate_private_key().

    Использование уникальных nonce/iv в каждом сообщении через ctx.npub.

Вся коммуникация после установки соединения полностью зашифрована и аутентифицирована.
17. Платформенная кросс-компатибельность

Код адаптирован для:

    Windows: с использованием WSAStartup, closesocket, INVALID_SOCKET, PlaySound.

    Unix/Linux: с использованием POSIX-функций socket, bind, listen, read, write, close, sigaction.

Использование директив #ifdef _WIN32 обеспечивает сборку одного исходного файла на обеих платформах.
18. Заключение

Данный сервер реализует:

    Безопасное подключение клиента.

    Шифрование всех передаваемых данных.

    Возможность общения в режиме реального времени.

    Кросс-платформенность и обработку системных сигналов.

    Структурированную обработку ошибок.

Код легко масштабируется: можно добавить логирование, аутентификацию, многопоточность или GUI-интерфейс.